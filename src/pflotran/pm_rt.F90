module PM_RT_class

  use PM_Base_class
!geh: using Reactive_Transport_module here fails with gfortran (internal 
!     compiler error)
!  use Reactive_Transport_module
  use Realization_class
  use Communicator_Base_module  
  use Option_module
  
  use PFLOTRAN_Constants_module

  implicit none

  private

#include "finclude/petscsys.h"

#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscmat.h"
#include "finclude/petscmat.h90"
#include "finclude/petscsnes.h"

  type, public, extends(pm_base_type) :: pm_rt_type
    class(realization_type), pointer :: realization
    class(communicator_type), pointer :: comm1
    class(communicator_type), pointer :: commN
    ! local variables
    PetscBool :: steady_flow
    PetscReal :: tran_weight_t0
    PetscReal :: tran_weight_t1
  contains
    procedure, public :: Init => PMRTInit
    procedure, public :: PMRTSetRealization
    procedure, public :: InitializeRun => PMRTInitializeRun
    procedure, public :: FinalizeRun => PMRTFinalizeRun
    procedure, public :: InitializeTimestep => PMRTInitializeTimestep
    procedure, public :: FinalizeTimestep => PMRTFinalizeTimestep
    procedure, public :: Residual => PMRTResidual
    procedure, public :: Jacobian => PMRTJacobian
    procedure, public :: UpdateTimestep => PMRTUpdateTimestep
    procedure, public :: PreSolve => PMRTPreSolve
    procedure, public :: PostSolve => PMRTPostSolve
    procedure, public :: AcceptSolution => PMRTAcceptSolution
    procedure, public :: CheckUpdatePre => PMRTCheckUpdatePre
    procedure, public :: CheckUpdatePost => PMRTCheckUpdatePost
    procedure, public :: TimeCut => PMRTTimeCut
    procedure, public :: UpdateSolution => PMRTUpdateSolution1
    procedure, public :: MaxChange => PMRTMaxChange
    procedure, public :: ComputeMassBalance => PMRTComputeMassBalance
    procedure, public :: SetTranWeights => SetTranWeights
    procedure, public :: Checkpoint => PMRTCheckpoint
    procedure, public :: Restart => PMRTRestart
    procedure, public :: Destroy => PMRTDestroy
  end type pm_rt_type
  
  type, public, extends(pm_base_header_type) :: pm_rt_header_type
    integer*8 :: checkpoint_activity_coefs
  end type pm_rt_header_type  
  PetscSizeT, parameter, private :: bagsize = 16
  
  public :: PMRTCreate

contains

! ************************************************************************** !

function PMRTCreate()
  ! 
  ! Creates reactive transport process models shell
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  implicit none
  
  class(pm_rt_type), pointer :: PMRTCreate

  class(pm_rt_type), pointer :: rt_pm
  
#ifdef PM_RT_DEBUG  
  print *, 'PMRTCreate()'
#endif
  
  allocate(rt_pm)
  nullify(rt_pm%option)
  nullify(rt_pm%output_option)
  nullify(rt_pm%realization)
  nullify(rt_pm%comm1)
  nullify(rt_pm%commN)
  
  ! local variables
  rt_pm%steady_flow = PETSC_FALSE
  rt_pm%tran_weight_t0 = 0.d0
  rt_pm%tran_weight_t1 = 0.d0

  call PMBaseCreate(rt_pm)
  rt_pm%name = 'PMRT'
  
  PMRTCreate => rt_pm
  
end function PMRTCreate

! ************************************************************************** !

subroutine PMRTInit(this)
  ! 
  ! Initializes variables associated with reactive transport
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

#ifndef SIMPLIFY
  use Discretization_module
  use Structured_Communicator_class
  use Unstructured_Communicator_class
  use Grid_module 
#endif  
  
  implicit none
  
  class(pm_rt_type) :: this

#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%Init()')
#endif
  
#ifndef SIMPLIFY  
  ! set up communicator
  select case(this%realization%discretization%itype)
    case(STRUCTURED_GRID, STRUCTURED_GRID_MIMETIC)
      this%commN => StructuredCommunicatorCreate()
    case(UNSTRUCTURED_GRID)
      this%commN => UnstructuredCommunicatorCreate()
  end select
  call this%commN%SetDM(this%realization%discretization%dm_ntrandof)
#endif

  ! set the communicator
  this%comm1 => this%realization%comm1
  
end subroutine PMRTInit

! ************************************************************************** !

subroutine PMRTSetRealization(this,realization)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Realization_class  

  implicit none
  
  class(pm_rt_type) :: this
  class(realization_type), pointer :: realization

#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%SetRealization()')
#endif
  
  this%realization => realization
  this%realization_base => realization
  
  if (realization%reaction%use_log_formulation) then
    this%solution_vec = realization%field%tran_log_xx
  else
    this%solution_vec = realization%field%tran_xx
  endif
  this%residual_vec = realization%field%tran_r
  
end subroutine PMRTSetRealization

! ************************************************************************** !

subroutine PMRTInitializeTimestep(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTInitializeTimestep, &
                                        RTUpdateTransportCoefs
  use Global_module

  implicit none
  
  class(pm_rt_type) :: this
  PetscReal :: time
 
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%InitializeTimestep()')
#endif
  
  this%option%tran_dt = this%option%dt

  if (this%option%print_screen_flag) then
    write(*,'(/,2("=")," REACTIVE TRANSPORT ",57("="))')
  endif
  
#if 0  
  call DiscretizationLocalToLocal(discretization, &
                                  this%realization%field%porosity_loc, &
                                  this%realization%field%porosity_loc,ONEDOF)
  call DiscretizationLocalToLocal(discretization, &
                                  this%realization%field%tortuosity_loc, &
                                  this%realization%field%tortuosity_loc,ONEDOF)
#endif  
  
  ! interpolate flow parameters/data
  ! this must remain here as these weighted values are used by both
  ! RTInitializeTimestep and RTTimeCut (which calls RTInitializeTimestep)
  if (this%option%nflowdof > 0 .and. .not. this%steady_flow) then
    call this%SetTranWeights()
    ! set densities and saturations to t
    call GlobalWeightAuxvars(this%realization,this%tran_weight_t0)
  endif

  call RTInitializeTimestep(this%realization)

  !geh: this is a bug and should be moved to PreSolve()
#if 1
  ! set densities and saturations to t+dt
  if (this%option%nflowdof > 0 .and. .not. this%steady_flow) then
    call GlobalWeightAuxVars(this%realization,this%tran_weight_t1)
  endif

  call RTUpdateTransportCoefs(this%realization)
#endif  

end subroutine PMRTInitializeTimestep

! ************************************************************************** !

subroutine PMRTPreSolve(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTUpdateTransportCoefs, &
                                        RTUpdateAuxVars
  use Reaction_Aux_module, only : ACT_COEF_FREQUENCY_OFF
  use Global_module  

  implicit none
  
  class(pm_rt_type) :: this
  
  PetscErrorCode :: ierr
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%UpdatePreSolve()')
#endif
  
#if 0
  ! set densities and saturations to t+dt
  if (this%option%nflowdof > 0 .and. .not. this%steady_flow) then
    call GlobalWeightAuxVars(this%realization,this%tran_weight_t1)
  endif

  call RTUpdateTransportCoefs(this%realization)
#endif  
  
  if (this%realization%reaction%act_coef_update_frequency /= &
      ACT_COEF_FREQUENCY_OFF) then
      call RTUpdateAuxVars(this%realization,PETSC_TRUE,PETSC_TRUE,PETSC_TRUE)
!       The below is set within RTUpdateAuxVarsPatch() when 
!         PETSC_TRUE,PETSC_TRUE,* are passed
!       patch%aux%RT%auxvars_up_to_date = PETSC_TRUE 
  endif
  if (this%realization%reaction%use_log_formulation) then
    call VecCopy(this%realization%field%tran_xx, &
                 this%realization%field%tran_log_xx,ierr);CHKERRQ(ierr)
    call VecLog(this%realization%field%tran_log_xx,ierr);CHKERRQ(ierr)
  endif
  
end subroutine PMRTPreSolve

! ************************************************************************** !

subroutine PMRTPostSolve(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  implicit none
  
  class(pm_rt_type) :: this
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%PostSolve()')
#endif
  
end subroutine PMRTPostSolve

! ************************************************************************** !

subroutine PMRTFinalizeTimestep(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 04/03/13
  ! 

  use Reactive_Transport_module, only : RTMaxChange
  use Global_module

  implicit none
  
  class(pm_rt_type) :: this
  PetscReal :: time  
  
#ifdef PM_RICHARDS_DEBUG  
  call printMsg(this%option,'PMRichards%FinalizeTimestep()')
#endif
  
  call RTMaxChange(this%realization)
  if (this%option%print_screen_flag) then
    write(*,'("  --> max chng: dcmx= ",1pe12.4," dc/dt= ",1pe12.4, &
            &" [mol/s]")') &
      this%option%dcmax,this%option%dcmax/this%option%tran_dt
  endif
  if (this%option%print_file_flag) then  
    write(this%option%fid_out,'("  --> max chng: dcmx= ",1pe12.4, &
                              &" dc/dt= ",1pe12.4," [mol/s]")') &
      this%option%dcmax,this%option%dcmax/this%option%tran_dt
  endif
  
end subroutine PMRTFinalizeTimestep

! ************************************************************************** !

function PMRTAcceptSolution(this)
  ! 
  ! PMRichardsAcceptSolution:
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  implicit none
  
  class(pm_rt_type) :: this
  
  PetscBool :: PMRTAcceptSolution
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%AcceptSolution()')
#endif
  ! do nothing
  PMRTAcceptSolution = PETSC_TRUE
  
end function PMRTAcceptSolution

! ************************************************************************** !

subroutine PMRTUpdateTimestep(this,dt,dt_max,iacceleration, &
                              num_newton_iterations,tfac)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  implicit none
  
  class(pm_rt_type) :: this
  PetscReal :: dt
  PetscReal :: dt_max
  PetscInt :: iacceleration
  PetscInt :: num_newton_iterations
  PetscReal :: tfac(:)
  
  PetscReal :: dtt
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%UpdateTimestep()')  
#endif
  
  dtt = dt
  if (num_newton_iterations <= iacceleration) then
    if (num_newton_iterations <= size(tfac)) then
      dtt = tfac(num_newton_iterations) * dt
    else
      dtt = 0.5d0 * dt
    endif
  else
!       dtt = 2.d0 * dt
    dtt = 0.5d0 * dt
  endif

  if (dtt > 2.d0 * dt) dtt = 2.d0 * dt
  if (dtt > dt_max) dtt = dt_max
  ! geh: see comment above under flow stepper
  dt = dtt

end subroutine PMRTUpdateTimestep

! ************************************************************************** !

recursive subroutine PMRTInitializeRun(this)
  ! 
  ! Initializes the time stepping
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/18/13
  ! 

  use Reactive_Transport_module, only : RTUpdateEquilibriumState, &
                                        RTJumpStartKineticSorption
  use Condition_Control_module
  use Reaction_Aux_module, only : ACT_COEF_FREQUENCY_OFF
  use Reactive_Transport_module, only : RTUpdateAuxVars, &
                                        RTClearActivityCoefficients

  implicit none
  
  class(pm_rt_type) :: this
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%InitializeRun()')
#endif
  
  ! restart
  if (this%option%restart_flag .and. &
      this%option%overwrite_restart_transport) then
    call RTClearActivityCoefficients(this%realization)
    call CondControlAssignTranInitCond(this%realization)  
  endif
  
  ! pass PETSC_FALSE to turn off update of kinetic state variables
  call PMRTUpdateSolution2(this,PETSC_FALSE)
  
#if 0
  if (this%option%jumpstart_kinetic_sorption .and. &
      this%option%time < 1.d-40) then
    ! only user jumpstart for a restarted simulation
    if (.not. this%option%restart_flag) then
      this%option%io_buffer = 'Only use JUMPSTART_KINETIC_SORPTION on a ' // &
        'restarted simulation.  ReactionEquilibrateConstraint() will ' // &
        'appropriately set sorbed initial concentrations for a normal ' // &
        '(non-restarted) simulation.'
      call printErrMsg(this%option)
    endif
    call RTJumpStartKineticSorption(this%realization)
  endif
  ! check on MAX_STEPS < 0 to quit after initialization.
#endif  
    
end subroutine PMRTInitializeRun

! ************************************************************************** !

recursive subroutine PMRTFinalizeRun(this)
  ! 
  ! Finalizes the time stepping
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/18/13
  ! 

  implicit none
  
  class(pm_rt_type) :: this
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%PMRTFinalizeRun()')
#endif
  
  ! do something here
  
  if (associated(this%next)) then
    call this%next%FinalizeRun()
  endif  
  
end subroutine PMRTFinalizeRun

! ************************************************************************** !

subroutine PMRTResidual(this,snes,xx,r,ierr)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTResidual

  implicit none
  
  class(pm_rt_type) :: this
  SNES :: snes
  Vec :: xx
  Vec :: r
  PetscErrorCode :: ierr
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%Residual()')  
#endif
  
  call RTResidual(snes,xx,r,this%realization,ierr)

end subroutine PMRTResidual

! ************************************************************************** !

subroutine PMRTJacobian(this,snes,xx,A,B,ierr)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTJacobian

  implicit none
  
  class(pm_rt_type) :: this
  SNES :: snes
  Vec :: xx
  Mat :: A, B
  PetscErrorCode :: ierr
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%Jacobian()')  
#endif

  call RTJacobian(snes,xx,A,B,this%realization,ierr)

end subroutine PMRTJacobian

! ************************************************************************** !

subroutine PMRTCheckUpdatePre(this,line_search,P,dP,changed,ierr)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTCheckUpdatePre

  implicit none
  
  class(pm_rt_type) :: this
  SNESLineSearch :: line_search
  Vec :: P
  Vec :: dP
  PetscBool :: changed
  PetscErrorCode :: ierr
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%CheckUpdatePre()')
#endif
  
#ifndef SIMPLIFY 
  call RTCheckUpdatePre(line_search,P,dP,changed,this%realization,ierr)
#endif

end subroutine PMRTCheckUpdatePre

! ************************************************************************** !

subroutine PMRTCheckUpdatePost(this,line_search,P0,dP,P1,dP_changed, &
                                  P1_changed,ierr)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTCheckUpdatePost

  implicit none
  
  class(pm_rt_type) :: this
  SNESLineSearch :: line_search
  Vec :: P0
  Vec :: dP
  Vec :: P1
  PetscBool :: dP_changed
  PetscBool :: P1_changed
  PetscErrorCode :: ierr
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%CheckUpdatePost()')
#endif
  
  call RTCheckUpdatePost(line_search,P0,dP,P1,dP_changed, &
                         P1_changed,this%realization,ierr)

end subroutine PMRTCheckUpdatePost

! ************************************************************************** !

subroutine PMRTTimeCut(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTTimeCut

  implicit none
  
  class(pm_rt_type) :: this
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%TimeCut()')
#endif
  
  this%option%tran_dt = this%option%dt
  if (this%option%nflowdof > 0 .and. .not. this%steady_flow) then
    call this%SetTranWeights()
  endif
  call RTTimeCut(this%realization)

end subroutine PMRTTimeCut

! ************************************************************************** !

subroutine PMRTUpdateSolution1(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module
  use Condition_module
  use Mass_Transfer_module

  implicit none
  
  class(pm_rt_type) :: this
                                ! update kinetics
  call PMRTUpdateSolution2(this,PETSC_TRUE)
  
end subroutine PMRTUpdateSolution1

! ************************************************************************** !

subroutine PMRTUpdateSolution2(this, update_kinetics)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module
  use Condition_module
  use Mass_Transfer_module

  implicit none
  
  class(pm_rt_type) :: this
  PetscBool :: update_kinetics
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%UpdateSolution()')
#endif
  
  ! begin from RealizationUpdate()
  call TranConditionUpdate(this%realization%transport_conditions, &
                           this%realization%option, &
                           this%realization%option%time)
  if (associated(this%realization%uniform_velocity_dataset)) then
    call RealizUpdateUniformVelocity(this%realization)
  endif  
  ! end from RealizationUpdate()
  ! The update of status must be in this order!
  call RTUpdateEquilibriumState(this%realization)
  if (update_kinetics) &
    call RTUpdateKineticState(this%realization)
  if (this%realization%reaction%update_porosity .or. &
      this%realization%reaction%update_tortuosity .or. &
      this%realization%reaction%update_permeability .or. &
      this%realization%reaction%update_mineral_surface_area) then
    call RealizationUpdatePropertiesTS(this%realization)
  endif
  
  call MassTransferUpdate(this%realization%rt_mass_transfer_list, &
                          this%realization%patch%grid, &
                          this%realization%option)
  
  if (this%realization%option%compute_mass_balance_new) then
    call RTUpdateMassBalance(this%realization)
  endif  

end subroutine PMRTUpdateSolution2     

! ************************************************************************** !

subroutine PMRTMaxChange(this)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTMaxChange

  implicit none
  
  class(pm_rt_type) :: this
  
#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%MaxChange()')
#endif
  
  call RTMaxChange(this%realization)

end subroutine PMRTMaxChange

! ************************************************************************** !

subroutine PMRTComputeMassBalance(this,mass_balance_array)
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTComputeMassBalance

  implicit none
  
  class(pm_rt_type) :: this
  PetscReal :: mass_balance_array(:)

#ifdef PM_RT_DEBUG  
  call printMsg(this%option,'PMRT%MassBalance()')
#endif

#ifndef SIMPLIFY 
  call RTComputeMassBalance(this%realization,mass_balance_array)
#endif

end subroutine PMRTComputeMassBalance

! ************************************************************************** !

subroutine SetTranWeights(this)
  ! 
  ! Sets the weights at t0 or t1 for transport
  ! 
  ! Author: Glenn Hammond
  ! Date: 01/17/11; 04/03/13
  ! 

  use Option_module

  implicit none
  
  class(pm_rt_type) :: this

  PetscReal :: flow_dt
  PetscReal :: flow_t0
  PetscReal :: flow_t1

  ! option%tran_time is the time at beginning of transport step
  flow_t0 = this%realization%patch%aux%Global%time_t
  flow_t1 = this%realization%patch%aux%Global%time_tpdt
  flow_dt = flow_t1-flow_t0
  this%tran_weight_t0 = max(0.d0,(this%option%time-flow_t0)/flow_dt)
  this%tran_weight_t1 = min(1.d0, &
                            (this%option%time+this%option%tran_dt-flow_t0)/ &
                            flow_dt)

end subroutine SetTranWeights

! ************************************************************************** !

subroutine PMRTCheckpoint(this,viewer)
  ! 
  ! Checkpoints flow reactive transport process model
  ! 
  ! Author: Glenn Hammond
  ! Date: 07/29/13
  ! 

  use Option_module
  use Realization_class
  use Realization_Base_class
  use Field_module
  use Discretization_module
  use Grid_module
  use Reactive_Transport_module, only : RTCheckpointKineticSorption  
  use Reaction_Aux_module, only : ACT_COEF_FREQUENCY_OFF
  use Variables_module, only : PRIMARY_ACTIVITY_COEF, &
                               SECONDARY_ACTIVITY_COEF, &
                               MINERAL_VOLUME_FRACTION
  
  implicit none

#include "finclude/petscviewer.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscbag.h"      

  interface PetscBagGetData

! ************************************************************************** !

    subroutine PetscBagGetData(bag,header,ierr)
      import :: pm_rt_header_type
      implicit none
#include "finclude/petscbag.h"      
      PetscBag :: bag
      class(pm_rt_header_type), pointer :: header
      PetscErrorCode :: ierr
    end subroutine
  end interface PetscBagGetData 

  PetscViewer :: viewer
  class(pm_rt_type) :: this
  PetscErrorCode :: ierr

  class(realization_type), pointer :: realization
  type(option_type), pointer :: option
  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization
  type(grid_type), pointer :: grid
  Vec :: global_vec
  PetscInt :: i

  class(pm_rt_header_type), pointer :: header
  PetscBag :: bag
  
  realization => this%realization
  option => realization%option
  field => realization%field
  discretization => realization%discretization
  grid => realization%patch%grid
  
  global_vec = 0
  
  call PetscBagCreate(option%mycomm,bagsize,bag,ierr);CHKERRQ(ierr)
  call PetscBagGetData(bag,header,ierr);CHKERRQ(ierr)
  call PetscBagRegisterInt(bag,header%checkpoint_activity_coefs,0, &
                           "checkpoint_activity_coefs","",ierr);CHKERRQ(ierr)
  call PetscBagRegisterInt(bag,header%ndof,0, &
                           "ndof","",ierr);CHKERRQ(ierr)
  if (associated(realization%reaction)) then
    if (realization%reaction%checkpoint_activity_coefs .and. &
        realization%reaction%act_coef_update_frequency /= &
        ACT_COEF_FREQUENCY_OFF) then
      header%checkpoint_activity_coefs = ONE_INTEGER
    else
      header%checkpoint_activity_coefs = ZERO_INTEGER
    endif
  else
    header%checkpoint_activity_coefs = ZERO_INTEGER
  endif
  !geh: %ndof should be pushed down to the base class, but this is not possible
  !     as long as option%ntrandof is used.
  header%ndof = option%ntrandof
  call PetscBagView(bag,viewer,ierr);CHKERRQ(ierr)
  call PetscBagDestroy(bag,ierr);CHKERRQ(ierr)
  
  if (option%ntrandof > 0) then
    call VecView(field%tran_xx, viewer, ierr);CHKERRQ(ierr)
    ! create a global vec for writing below 
    if (global_vec == 0) then
      call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                      global_vec,GLOBAL,option)
    endif
    if (realization%reaction%checkpoint_activity_coefs .and. &
        realization%reaction%act_coef_update_frequency /= &
        ACT_COEF_FREQUENCY_OFF) then
      ! allocated vector
      do i = 1, realization%reaction%naqcomp
        call RealizationGetVariable(realization,global_vec, &
                                   PRIMARY_ACTIVITY_COEF,i)
        call VecView(global_vec,viewer,ierr);CHKERRQ(ierr)
      enddo
      do i = 1, realization%reaction%neqcplx
        call RealizationGetVariable(realization,global_vec, &
                                   SECONDARY_ACTIVITY_COEF,i)
        call VecView(global_vec,viewer,ierr);CHKERRQ(ierr)
      enddo
    endif
    ! mineral volume fractions for kinetic minerals
    if (realization%reaction%mineral%nkinmnrl > 0) then
      do i = 1, realization%reaction%mineral%nkinmnrl
        call RealizationGetVariable(realization,global_vec, &
                                   MINERAL_VOLUME_FRACTION,i)
        call VecView(global_vec,viewer,ierr);CHKERRQ(ierr)
      enddo
    endif
    ! sorbed concentrations for multirate kinetic sorption
    if (realization%reaction%surface_complexation%nkinmrsrfcplxrxn > 0 .and. &
        .not.option%transport%no_checkpoint_kinetic_sorption) then
      ! PETSC_TRUE flag indicates write to file
      call RTCheckpointKineticSorption(realization,viewer,PETSC_TRUE)
    endif
  endif

  if (global_vec /= 0) then
    call VecDestroy(global_vec,ierr);CHKERRQ(ierr)
  endif
  
end subroutine PMRTCheckpoint

! ************************************************************************** !

subroutine PMRTRestart(this,viewer)
  ! 
  ! Restarts flow reactive transport process model
  ! 
  ! Author: Glenn Hammond
  ! Date: 07/29/13
  ! 

  use Option_module
  use Realization_class
  use Realization_Base_class
  use Field_module
  use Discretization_module
  use Grid_module
  use Reactive_Transport_module, only : RTCheckpointKineticSorption, &
                                        RTUpdateAuxVars
  use Reaction_Aux_module, only : ACT_COEF_FREQUENCY_OFF
  use Variables_module, only : PRIMARY_ACTIVITY_COEF, &
                               SECONDARY_ACTIVITY_COEF, &
                               MINERAL_VOLUME_FRACTION
  
  implicit none

#include "finclude/petscviewer.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscbag.h"      

  interface PetscBagGetData

! ************************************************************************** !

    subroutine PetscBagGetData(bag,header,ierr)
      import :: pm_rt_header_type
      implicit none
#include "finclude/petscbag.h"      
      PetscBag :: bag
      class(pm_rt_header_type), pointer :: header
      PetscErrorCode :: ierr
    end subroutine
  end interface PetscBagGetData 

  PetscViewer :: viewer
  class(pm_rt_type) :: this
  PetscErrorCode :: ierr

  class(realization_type), pointer :: realization
  type(option_type), pointer :: option
  type(field_type), pointer :: field
  type(discretization_type), pointer :: discretization
  type(grid_type), pointer :: grid
  Vec :: global_vec, local_vec
  PetscInt :: i

  class(pm_rt_header_type), pointer :: header
  PetscBag :: bag
  
  realization => this%realization
  option => realization%option
  field => realization%field
  discretization => realization%discretization
  grid => realization%patch%grid
  
  global_vec = 0
  local_vec = 0
  
  call PetscBagCreate(this%option%mycomm, bagsize, bag, ierr);CHKERRQ(ierr)
  call PetscBagGetData(bag, header, ierr);CHKERRQ(ierr)
  call PetscBagRegisterInt(bag,header%checkpoint_activity_coefs,0, &
                           "checkpoint_activity_coefs","",ierr);CHKERRQ(ierr)
  call PetscBagRegisterInt(bag,header%ndof,0, &
                           "ndof","",ierr);CHKERRQ(ierr)
  call PetscBagLoad(viewer, bag, ierr);CHKERRQ(ierr)
  option%ntrandof = header%ndof
  
  call VecLoad(field%tran_xx,viewer,ierr);CHKERRQ(ierr)
  call DiscretizationGlobalToLocal(discretization,field%tran_xx, &
                                    field%tran_xx_loc,NTRANDOF)
  call VecCopy(field%tran_xx,field%tran_yy,ierr);CHKERRQ(ierr)

  if (global_vec == 0) then
    call DiscretizationCreateVector(realization%discretization,ONEDOF, &
                                    global_vec,GLOBAL,option)
  endif    
  if (header%checkpoint_activity_coefs == ONE_INTEGER) then
    call DiscretizationCreateVector(discretization,ONEDOF,local_vec, &
                                    LOCAL,option)
    do i = 1, realization%reaction%naqcomp
      call VecLoad(global_vec,viewer,ierr);CHKERRQ(ierr)
      call DiscretizationGlobalToLocal(discretization,global_vec, &
                                        local_vec,ONEDOF)
      call RealizationSetVariable(realization,local_vec,LOCAL, &
                                  PRIMARY_ACTIVITY_COEF,i)
    enddo
    do i = 1, realization%reaction%neqcplx
      call VecLoad(global_vec,viewer,ierr);CHKERRQ(ierr)
      call DiscretizationGlobalToLocal(discretization,global_vec, &
                                        local_vec,ONEDOF)
      call RealizationSetVariable(realization,local_vec,LOCAL, &
                                  SECONDARY_ACTIVITY_COEF,i)
    enddo
  endif
  ! mineral volume fractions for kinetic minerals
  if (realization%reaction%mineral%nkinmnrl > 0) then
    do i = 1, realization%reaction%mineral%nkinmnrl
      ! have to load the vecs no matter what
      call VecLoad(global_vec,viewer,ierr);CHKERRQ(ierr)
      if (.not.option%transport%no_restart_mineral_vol_frac) then
        call RealizationSetVariable(realization,global_vec,GLOBAL, &
                                    MINERAL_VOLUME_FRACTION,i)
      endif
    enddo
  endif
  ! sorbed concentrations for multirate kinetic sorption
  if (realization%reaction%surface_complexation%nkinmrsrfcplxrxn > 0 .and. &
      .not.option%transport%no_checkpoint_kinetic_sorption .and. &
      ! we need to fix this.  We need something to skip over the reading
      ! of sorbed concentrations altogether if they do not exist in the
      ! checkpoint file
      .not.option%transport%no_restart_kinetic_sorption) then
    ! PETSC_FALSE flag indicates read from file
    call RTCheckpointKineticSorption(realization,viewer,PETSC_FALSE)
  endif
    
  ! We are finished, so clean up.
  if (global_vec /= 0) then
    call VecDestroy(global_vec,ierr);CHKERRQ(ierr)
  endif
  if (local_vec /= 0) then
    call VecDestroy(local_vec,ierr);CHKERRQ(ierr)
  endif
  
  call PetscBagDestroy(bag,ierr);CHKERRQ(ierr)
  
  if (realization%reaction%use_full_geochemistry) then
                                     ! cells     bcs        act coefs.
    call RTUpdateAuxVars(realization,PETSC_FALSE,PETSC_TRUE,PETSC_FALSE)
  endif
  ! do not update kinetics.
  call PMRTUpdateSolution2(this,PETSC_FALSE)
  
end subroutine PMRTRestart

! ************************************************************************** !

subroutine PMRTDestroy(this)
  ! 
  ! Destroys RT process model
  ! 
  ! Author: Glenn Hammond
  ! Date: 03/14/13
  ! 

  use Reactive_Transport_module, only : RTDestroy

  implicit none
  
  class(pm_rt_type) :: this

  call RTDestroy(this%realization)
  ! destroyed in realization
  nullify(this%comm1)
  call this%commN%Destroy()
  if (associated(this%commN)) deallocate(this%commN)
  nullify(this%commN)  

end subroutine PMRTDestroy
  
end module PM_RT_class
