module Realization_class
  
  use Realization_Base_class

  use Option_module
  use Output_Aux_module
  use Input_Aux_module
  use Region_module
  use Condition_module
  use Constraint_module
  use Material_module
  use Saturation_Function_module
  use Characteristic_Curves_module
  use Dataset_Base_class
  use Fluid_module
  use Discretization_module
  use Field_module
  use Debug_module
  use Uniform_Velocity_module
  use Waypoint_module
  use Output_Aux_module
  use Mass_Transfer_module  
  
  use Reaction_Aux_module
  
  use Patch_module
  
  use PFLOTRAN_Constants_module
  use Root_module

  implicit none

private

#include "finclude/petscsys.h"
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
  type, public, extends(realization_base_type) :: realization_type

    type(region_list_type), pointer :: regions
    type(condition_list_type), pointer :: flow_conditions
    type(tran_condition_list_type), pointer :: transport_conditions
    type(tran_constraint_list_type), pointer :: transport_constraints
    
    type(tran_constraint_type), pointer :: sec_transport_constraint
    type(material_property_type), pointer :: material_properties
    type(fluid_property_type), pointer :: fluid_properties
    type(fluid_property_type), pointer :: fluid_property_array(:)
    type(saturation_function_type), pointer :: saturation_functions
    class(characteristic_curves_type), pointer :: characteristic_curves
    class(dataset_base_type), pointer :: datasets
    
    type(uniform_velocity_dataset_type), pointer :: uniform_velocity_dataset
    character(len=MAXSTRINGLENGTH) :: nonuniform_velocity_filename
    
    type(waypoint_list_type), pointer :: waypoint_list

    type(root_property_type), pointer :: root_properties
    type(root_property_ptr_type), pointer :: root_property_array(:)

  end type realization_type

  interface RealizationCreate
    module procedure RealizationCreate1
    module procedure RealizationCreate2
  end interface
  
  public :: RealizationCreate, &
            RealizationStrip, &
            RealizationDestroyLegacy, &
            RealizationProcessCouplers, &
            RealizationInitAllCouplerAuxVars, &
            RealizationProcessConditions, &
            RealizationUpdate, &
            RealizationAddWaypointsToList, &
            RealizationCreateDiscretization, &
            RealizationLocalizeRegions, &
            RealizationAddCoupler, &
            RealizationAddStrata, &
            RealizationAddObservation, &
            RealizUpdateUniformVelocity, &
            RealizationRevertFlowParameters, &
!            RealizationGetVariable, &
!            RealizGetVariableValueAtCell, &
!            RealizationSetVariable, &
            RealizationPrintCouplers, &
            RealizationInitConstraints, &
            RealProcessMatPropAndSatFunc, &
            RealProcessFluidProperties, &
            RealizationUpdatePropertiesTS, &
            RealizationUpdatePropertiesNI, &
            RealizationCountCells, &
            RealizationPrintGridStatistics, &
            RealizationSetUpBC4Faces, &
            RealizationPassPtrsToPatches, &
            RealLocalToLocalWithArray, &
            RealizationCalculateCFL1Timestep, &
            RealizationNonInitializedData, &
            RealizUpdateAllCouplerAuxVars, &
            RealizCreateSyncWaypointList

  !TODO(intel)
  ! public from Realization_Base_class
  !public :: RealizationGetVariable

contains

! ************************************************************************** !

function RealizationCreate1()
  ! 
  ! Allocates and initializes a new Realization object
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/25/07
  ! 

  implicit none
  
  type(realization_type), pointer :: RealizationCreate1
  
  type(realization_type), pointer :: realization
  type(option_type), pointer :: option
  
  nullify(option)
  RealizationCreate1 => RealizationCreate2(option)
  
end function RealizationCreate1  

! ************************************************************************** !

function RealizationCreate2(option)
  ! 
  ! Allocates and initializes a new Realization object
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/25/07
  ! 

  implicit none
  
  type(option_type), pointer :: option
  
  type(realization_type), pointer :: RealizationCreate2
  
  type(realization_type), pointer :: realization
  
  allocate(realization)
  call RealizationBaseInit(realization,option)

  allocate(realization%regions)
  call RegionInitList(realization%regions)

  allocate(realization%flow_conditions)
  call FlowConditionInitList(realization%flow_conditions)
  allocate(realization%transport_conditions)
  call TranConditionInitList(realization%transport_conditions)
  allocate(realization%transport_constraints)
  call TranConstraintInitList(realization%transport_constraints)

  nullify(realization%material_properties)
  nullify(realization%fluid_properties)
  nullify(realization%fluid_property_array)
  nullify(realization%saturation_functions)
  nullify(realization%characteristic_curves)
  nullify(realization%datasets)
  nullify(realization%uniform_velocity_dataset)
  nullify(realization%sec_transport_constraint)
  realization%nonuniform_velocity_filename = ''

  nullify(realization%waypoint_list)

  nullify(realization%root_properties)
  nullify(realization%root_property_array)

  RealizationCreate2 => realization
  
end function RealizationCreate2 

! ************************************************************************** !

subroutine RealizationCreateDiscretization(realization)
  ! 
  ! Creates grid
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Grid_module
  use Unstructured_Grid_Aux_module
  use Unstructured_Grid_module, only : UGridEnsureRightHandRule
  use Structured_Grid_module, only : StructGridCreateTVDGhosts
  use MFD_module
  use Coupler_module
  use Discretization_module
  use Unstructured_Cell_module
  use DM_Kludge_module
  use Variables_module, only : VOLUME
  use Structured_Communicator_class, only : StructuredCommunicatorCreate
  use Unstructured_Communicator_class, only : UnstructuredCommunicatorCreate
  
  implicit none
  
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

  type(realization_type) :: realization
  
  type(discretization_type), pointer :: discretization
  type(grid_type), pointer :: grid
  type(field_type), pointer :: field
  type(option_type), pointer :: option
  type(coupler_type), pointer :: boundary_condition
  PetscErrorCode :: ierr
  PetscInt, allocatable :: int_tmp(:)
  PetscInt :: test,j, num_LP_dof
  PetscOffset :: i_da
  PetscReal, pointer :: real_tmp(:)
  type(dm_ptr_type), pointer :: dm_ptr
  Vec :: is_bnd_vec
  PetscInt :: ivar

  option => realization%option
  field => realization%field
 
  discretization => realization%discretization
  
  call DiscretizationCreateDMs(discretization, option%nflowdof, &
                               option%ntrandof, option%nphase, &
                               option%ngeomechdof, option%n_stress_strain_dof, &
                               option)

  ! 1 degree of freedom, global
  call DiscretizationCreateVector(discretization,ONEDOF,field%work, &
                                  GLOBAL,option)
  call DiscretizationDuplicateVector(discretization,field%work, &
                                     field%porosity0)
  call DiscretizationDuplicateVector(discretization,field%work, &
                                     field%tortuosity0)
  call DiscretizationDuplicateVector(discretization,field%work, &
                                     field%volume0)

  ! 1 degree of freedom, local
  call DiscretizationCreateVector(discretization,ONEDOF,field%work_loc, &
                                  LOCAL,option)
  call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                     field%porosity_mnrl_loc)
  
  if (option%nflowdof > 0) then

    ! 1-dof global  
    call DiscretizationDuplicateVector(discretization,field%work, &
                                       field%perm0_xx)
    call DiscretizationDuplicateVector(discretization,field%work, &
                                       field%perm0_yy)
    call DiscretizationDuplicateVector(discretization,field%work, &
                                       field%perm0_zz)
    if (discretization%itype == STRUCTURED_GRID_MIMETIC.or. &
        discretization%itype == UNSTRUCTURED_GRID_MIMETIC) then
      call DiscretizationDuplicateVector(discretization,field%work, &
                                         field%perm0_xz)
      call DiscretizationDuplicateVector(discretization,field%work, &
                                         field%perm0_xy)
      call DiscretizationDuplicateVector(discretization,field%work, &
                                         field%perm0_yz)
    endif

    ! 1-dof local
    call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                       field%ithrm_loc)
    call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                       field%icap_loc)
    call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                       field%iphas_loc)
    call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                       field%iphas_old_loc)
    
    ! ndof degrees of freedom, global
    call DiscretizationCreateVector(discretization,NFLOWDOF,field%flow_xx, &
                                    GLOBAL,option)
    call DiscretizationDuplicateVector(discretization,field%flow_xx, &
                                       field%flow_yy)
    call DiscretizationDuplicateVector(discretization,field%flow_xx, &
                                       field%flow_dxx)
    call DiscretizationDuplicateVector(discretization,field%flow_xx, &
                                       field%flow_r)
    call DiscretizationDuplicateVector(discretization,field%flow_xx, &
                                       field%flow_accum)

    ! ndof degrees of freedom, local
    call DiscretizationCreateVector(discretization,NFLOWDOF,field%flow_xx_loc, &
                                    LOCAL,option)

    if (option%root_system) then
      call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                         field%kcomp_loc)
      !call DiscretizationDuplicateVector(discretization,field%work_loc, &
      !                                   field%ssd_loc)
      call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                         field%hthreshold_loc)
      call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                         field%tact_loc)
    endif

  endif

  if (option%ntrandof > 0) then
    if (option%transport%reactive_transport_coupling == GLOBAL_IMPLICIT) then
      ! ndof degrees of freedom, global
      call DiscretizationCreateVector(discretization,NTRANDOF,field%tran_xx, &
                                      GLOBAL,option)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_yy)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_dxx)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_r)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_accum)

      ! ndof degrees of freedom, local
      call DiscretizationCreateVector(discretization,NTRANDOF,field%tran_xx_loc, &
                                      LOCAL,option)
                                      
      if (realization%reaction%use_log_formulation) then
        call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                           field%tran_log_xx)
        call DiscretizationDuplicateVector(discretization,field%tran_xx_loc, &
                                           field%tran_work_loc)
      endif
 
    else ! operator splitting
      ! ndof degrees of freedom, global
      ! create the 1 dof vector for solving the individual linear systems
      call DiscretizationCreateVector(discretization,ONEDOF,field%tran_rhs_coef, &
                                      GLOBAL,option)
      ! create the ntran dof vector for storage of the solution
      call DiscretizationCreateVector(discretization,NTRANDOF,field%tran_xx, &
                                      GLOBAL,option)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_yy)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_dxx)
      call DiscretizationDuplicateVector(discretization,field%tran_xx, &
                                         field%tran_rhs)

      ! ndof degrees of freedom, local
      ! again, just for storage of the current colution
      call DiscretizationCreateVector(discretization,NTRANDOF,field%tran_xx_loc, &
                                      LOCAL,option)

    endif
    
  endif

  select case(discretization%itype)
    case(STRUCTURED_GRID, STRUCTURED_GRID_MIMETIC)
      grid => discretization%grid
      ! set up nG2L, nL2G, etc.
      call GridMapIndices(grid, &
                          discretization%dm_1dof, &
                          discretization%stencil_type,&
                          discretization%lsm_flux_method, &
                          option)
      if (option%itranmode == EXPLICIT_ADVECTION) then
        call StructGridCreateTVDGhosts(grid%structured_grid, &
                                       realization%reaction%naqcomp, &
                                       field%tran_xx, &
                                       discretization%dm_1dof%dm, &
                                       field%tvd_ghosts, &
                                       discretization%tvd_ghost_scatter, &
                                       option)
      endif
      call GridComputeSpacing(grid,option)
      call GridComputeCoordinates(grid,discretization%origin,option)
      call GridComputeVolumes(grid,field%volume0,option)
      ! set up internal connectivity, distance, etc.
      call GridComputeInternalConnect(grid,option)
      if (discretization%itype == STRUCTURED_GRID_MIMETIC) then
          call GridComputeCell2FaceConnectivity(grid, discretization%MFD, option)
      end if
      if (discretization%lsm_flux_method) then
        call DiscretizationDuplicateVector(discretization,field%work_loc, &
                                          is_bnd_vec)
        call GridComputeNeighbors(grid,field%work_loc,option)
        call DiscretizationLocalToLocal(discretization,field%work_loc,is_bnd_vec,ONEDOF)
        call GridSaveBoundaryCellInfo(discretization%grid,is_bnd_vec,option)
        call VecDestroy(is_bnd_vec,ierr);CHKERRQ(ierr)
      endif
    case(UNSTRUCTURED_GRID,UNSTRUCTURED_GRID_MIMETIC)
      grid => discretization%grid
      ! set up nG2L, NL2G, etc.
      call GridMapIndices(grid, &
                          discretization%dm_1dof, &
                          discretization%stencil_type,&
                          discretization%lsm_flux_method, &
                          option)
      call GridComputeCoordinates(grid,discretization%origin,option, & 
                                    discretization%dm_1dof%ugdm) 
      if (grid%itype == IMPLICIT_UNSTRUCTURED_GRID) then
        call UGridEnsureRightHandRule(grid%unstructured_grid,grid%x, &
                                      grid%y,grid%z,grid%nG2A,grid%nL2G, &
                                      option)
      endif
      ! set up internal connectivity, distance, etc.
      call GridComputeInternalConnect(grid,option, &
                                      discretization%dm_1dof%ugdm) 
      call GridComputeVolumes(grid,field%volume0,option)
#ifdef MFD_UGRID
      call GridComputeCell2FaceConnectivity(discretization%grid,discretization%MFD,option)
#endif
  end select
 
  ! Vectors with face degrees of freedom
#ifdef DASVYAT
  if (discretization%itype == STRUCTURED_GRID_MIMETIC .or. &
        discretization%itype == UNSTRUCTURED_GRID_MIMETIC) then

    if (option%nflowdof > 0) then
      num_LP_dof = (grid%nlmax_faces + grid%nlmax)*option%nflowdof
      call VecCreateMPI(option%mycomm, num_LP_dof, &
                  PETSC_DETERMINE,field%flow_xx_faces,ierr);CHKERRQ(ierr)
      call VecSetBlockSize(field%flow_xx_faces,option%nflowdof, &
                           ierr);CHKERRQ(ierr)

      call DiscretizationDuplicateVector(discretization, field%flow_xx_faces, &
                                        field%flow_r_faces)
      call DiscretizationDuplicateVector(discretization, field%flow_xx_faces, &
                                        field%flow_dxx_faces)
      call DiscretizationDuplicateVector(discretization, field%flow_xx_faces, &
                                        field%flow_yy_faces)

      call VecCreateSeq(PETSC_COMM_SELF, (grid%ngmax_faces + grid%ngmax)*option%nflowdof, &
                                              field%flow_xx_loc_faces,  &
                        ierr);CHKERRQ(ierr)
      call VecSetBlockSize(field%flow_xx_loc_faces,option%nflowdof, &
                           ierr);CHKERRQ(ierr)

      call DiscretizationDuplicateVector(discretization, field%flow_xx_loc_faces, &
                                          field%flow_r_loc_faces)
      call DiscretizationDuplicateVector(discretization, field%flow_xx_loc_faces, &
                                          field%flow_bc_loc_faces)
      call DiscretizationDuplicateVector(discretization, field%flow_xx_loc_faces, &
                                          field%work_loc_faces)
     endif

    call RealizationCreatenG2LP(realization)

    dm_ptr => DiscretizationGetDMPtrFromIndex(discretization, NFLOWDOF)
    call GridComputeGlobalCell2FaceConnectivity(grid, discretization%MFD, &
                                                  dm_ptr%dm, NFLOWDOF, option)
   endif
#endif
 
  ! initialize to UNINITIALIZED_DOUBLE for check later that verifies all values 
  ! have been set
  call VecSet(field%porosity0,UNINITIALIZED_DOUBLE,ierr);CHKERRQ(ierr)

  ! Allocate vectors to hold temporally average output quantites
  if (realization%output_option%aveg_output_variable_list%nvars>0) then

    field%nvars = realization%output_option%aveg_output_variable_list%nvars
    allocate(field%avg_vars_vec(field%nvars))

    do ivar=1,field%nvars
      call DiscretizationDuplicateVector(discretization,field%work, &
                                         field%avg_vars_vec(ivar))
      call VecSet(field%avg_vars_vec(ivar),0.d0,ierr);CHKERRQ(ierr)
    enddo
  endif
       
  ! Allocate vectors to hold flowrate quantities
  if (realization%output_option%print_hdf5_mass_flowrate.or. &
     realization%output_option%print_hdf5_energy_flowrate.or. &
     realization%output_option%print_hdf5_aveg_mass_flowrate.or. &
     realization%output_option%print_hdf5_aveg_energy_flowrate) then
    call VecCreateMPI(option%mycomm, &
        (option%nflowdof*MAX_FACE_PER_CELL+1)*realization%patch%grid%nlmax, &
        PETSC_DETERMINE,field%flowrate_inst,ierr);CHKERRQ(ierr)
    call VecSet(field%flowrate_inst,0.d0,ierr);CHKERRQ(ierr)
  endif

  ! Allocate vectors to hold velocity at face
  if (realization%output_option%print_hdf5_vel_face) then

    ! vx
    call VecCreateMPI(option%mycomm, &
        (option%nflowdof*MAX_FACE_PER_CELL+1)*realization%patch%grid%nlmax, &
        PETSC_DETERMINE,field%vx_face_inst,ierr);CHKERRQ(ierr)
    call VecSet(field%vx_face_inst,0.d0,ierr);CHKERRQ(ierr)

    ! vy and vz
    call VecDuplicate(field%vx_face_inst,field%vy_face_inst, &
                      ierr);CHKERRQ(ierr)
    call VecDuplicate(field%vx_face_inst,field%vz_face_inst, &
                      ierr);CHKERRQ(ierr)
  endif

  if (realization%output_option%print_explicit_flowrate) then
    call VecCreateMPI(option%mycomm, &
         size(grid%unstructured_grid%explicit_grid%connections,2), &
         PETSC_DETERMINE,field%flowrate_inst,ierr);CHKERRQ(ierr)
    call VecSet(field%flowrate_inst,0.d0,ierr);CHKERRQ(ierr)
  endif
    
  ! If average flowrate has to be saved, create a vector for it
  if (realization%output_option%print_hdf5_aveg_mass_flowrate.or. &
      realization%output_option%print_hdf5_aveg_energy_flowrate) then
    call VecCreateMPI(option%mycomm, &
        (option%nflowdof*MAX_FACE_PER_CELL+1)*realization%patch%grid%nlmax, &
        PETSC_DETERMINE,field%flowrate_aveg,ierr);CHKERRQ(ierr)
    call VecSet(field%flowrate_aveg,0.d0,ierr);CHKERRQ(ierr)
  endif

  select case(realization%discretization%itype)
    case(STRUCTURED_GRID, STRUCTURED_GRID_MIMETIC)
      realization%comm1 => StructuredCommunicatorCreate()
    case(UNSTRUCTURED_GRID)
      realization%comm1 => UnstructuredCommunicatorCreate()
  end select
  call realization%comm1%SetDM(discretization%dm_1dof)

end subroutine RealizationCreateDiscretization

! ************************************************************************** !

subroutine RealizationLocalizeRegions(realization)
  ! 
  ! Localizes regions within each patch
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Option_module
  use String_module
  use Grid_module

  implicit none
  
  type(realization_type) :: realization
  
  type (region_type), pointer :: cur_region, cur_region2
  type(option_type), pointer :: option

  option => realization%option

  ! check to ensure that region names are not duplicated
  cur_region => realization%regions%first
  do
    if (.not.associated(cur_region)) exit
    cur_region2 => cur_region%next
    do
      if (.not.associated(cur_region2)) exit
      if (StringCompare(cur_region%name,cur_region2%name,MAXWORDLENGTH)) then
        option%io_buffer = 'Duplicate region names: ' // trim(cur_region%name)
        call printErrMsg(option)
      endif
      cur_region2 => cur_region2%next
    enddo
    cur_region => cur_region%next
  enddo

  call PatchLocalizeRegions(realization%patch,realization%regions, &
                            realization%option)

end subroutine RealizationLocalizeRegions

! ************************************************************************** !

subroutine RealizationPassPtrsToPatches(realization)
  ! 
  ! Sets patch%field => realization%field
  ! 
  ! Author: Glenn Hammond
  ! Date: 01/12/11
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  
  realization%patch%field => realization%field
  realization%patch%datasets => realization%datasets
  realization%patch%reaction => realization%reaction
  
end subroutine RealizationPassPtrsToPatches

! ************************************************************************** !

subroutine RealizationAddCoupler(realization,coupler)
  ! 
  ! Adds a copy of a coupler to a list
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Coupler_module

  implicit none
  
  type(realization_type) :: realization
  type(coupler_type), pointer :: coupler
  
  type(patch_type), pointer :: patch
  
  type(coupler_type), pointer :: new_coupler
  
  patch => realization%patch
  
  ! only add to flow list for now, since they will be split out later
  new_coupler => CouplerCreate(coupler)
  select case(coupler%itype)
    case(BOUNDARY_COUPLER_TYPE)
      call CouplerAddToList(new_coupler,patch%boundary_conditions)
    case(INITIAL_COUPLER_TYPE)
      call CouplerAddToList(new_coupler,patch%initial_conditions)
    case(SRC_SINK_COUPLER_TYPE)
      call CouplerAddToList(new_coupler,patch%source_sinks)
  end select
  nullify(new_coupler)

  call CouplerDestroy(coupler)
 
end subroutine RealizationAddCoupler

! ************************************************************************** !

subroutine RealizationCreatenG2LP(realization)
  ! 
  ! This routine sets up nG2LP() mapping for MIMETIC discretization.
  ! nG2LP: For a given ghosted cell ID, return the index within the PETSc
  ! solution vector that contains solution at cell centers + cell faces.
  ! The index returned is in PETSc order (0-based).
  ! 
  ! Author: ???
  ! Date: ???
  ! 

  use Grid_module

  implicit none
#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"
#include "finclude/petscmat.h"
#include "finclude/petscmat.h90"
#include "finclude/petscdm.h"
#include "finclude/petscdm.h90"
#include "finclude/petscis.h"
#include "finclude/petscis.h90"
#include "finclude/petscviewer.h"
#include "finclude/petscsnes.h"
#include "finclude/petscpc.h"
#include "finclude/petscsys.h"

  type(realization_type) :: realization

  type(option_type), pointer :: option
  type(discretization_type), pointer :: discretization
  type(grid_type), pointer :: grid
  PetscInt :: global_offset
  PetscInt :: ghosted_id
  PetscInt :: local_id
  PetscInt :: num_ghosted
  PetscErrorCode :: ierr

  Vec :: vec_LP_cell_id
  Vec :: vec_LP_cell_id_loc

  IS :: is_ghosted, is_global
  VecScatter :: VC_global2ghosted

  PetscScalar, pointer :: lp_cell_ids(:), lp_cell_ids_loc(:)
  PetscInt, pointer :: int_tmp_gh(:), int_tmp_gl(:)

  option => realization%option
  discretization => realization%discretization
  grid => discretization%grid
  
  global_offset = 0
  grid%global_faces_offset = 0
  grid%global_cell_offset = 0

  allocate(grid%nG2LP(grid%ngmax))

  call MPI_Exscan(grid%nlmax_faces, grid%global_faces_offset, &
                  ONE_INTEGER,MPI_INTEGER,MPI_SUM,option%mycomm,ierr)
  call MPI_Exscan(grid%nlmax, grid%global_cell_offset, &
                  ONE_INTEGER,MPI_INTEGER,MPI_SUM,option%mycomm,ierr)

  global_offset = grid%global_faces_offset + grid%global_cell_offset

  call DiscretizationCreateVector(discretization,ONEDOF,vec_LP_cell_id, &
                                  GLOBAL,option)
  call DiscretizationCreateVector(discretization,ONEDOF,vec_LP_cell_id_loc, &
                                  LOCAL,option)
  call VecGetArrayF90(vec_LP_cell_id,lp_cell_ids,ierr);CHKERRQ(ierr)
  do local_id=1,grid%nlmax
    grid%nG2LP(grid%nL2G(local_id))=global_offset+grid%nlmax_faces+local_id-1
    lp_cell_ids(local_id)=global_offset+grid%nlmax_faces+local_id
  enddo
  call VecRestoreArrayF90(vec_LP_cell_id,lp_cell_ids,ierr);CHKERRQ(ierr)

  allocate(int_tmp_gh(grid%ngmax-grid%nlmax))
  allocate(int_tmp_gl(grid%ngmax-grid%nlmax))

  num_ghosted = 1
  do ghosted_id = 1,grid%ngmax
    if (grid%nG2L(ghosted_id) < 1) then
      int_tmp_gh(num_ghosted) = ghosted_id - 1
      int_tmp_gl(num_ghosted) = grid%nG2P(ghosted_id)
      num_ghosted=num_ghosted+1
    endif
  enddo

  call ISCreateBlock(option%mycomm, ONEDOF, grid%ngmax - grid%nlmax, &
                     int_tmp_gh, PETSC_COPY_VALUES, is_ghosted,  &
                     ierr);CHKERRQ(ierr)
  call ISCreateBlock(option%mycomm, ONEDOF, grid%ngmax - grid%nlmax, &
                     int_tmp_gl, PETSC_COPY_VALUES, is_global,  &
                     ierr);CHKERRQ(ierr)
  call VecScatterCreate(vec_LP_cell_id, is_global, vec_LP_cell_id_loc, &
                        is_ghosted, VC_global2ghosted, ierr);CHKERRQ(ierr)
  deallocate(int_tmp_gh)
  deallocate(int_tmp_gl)

  call VecScatterBegin(VC_global2ghosted, vec_LP_cell_id, vec_LP_cell_id_loc, &
                      INSERT_VALUES,SCATTER_FORWARD,ierr);CHKERRQ(ierr)
  call VecScatterEnd(VC_global2ghosted, vec_LP_cell_id, vec_LP_cell_id_loc, &
                      INSERT_VALUES,SCATTER_FORWARD,ierr);CHKERRQ(ierr)

  call VecGetArrayF90(vec_LP_cell_id_loc,lp_cell_ids_loc,ierr);CHKERRQ(ierr)
  do ghosted_id=1,grid%ngmax
    if (grid%nG2L(ghosted_id)<1) then
      grid%nG2LP(ghosted_id)=int(lp_cell_ids_loc(ghosted_id))-1
    endif
  end do
  call VecRestoreArrayF90(vec_LP_cell_id_loc,lp_cell_ids_loc, &
                          ierr);CHKERRQ(ierr)

  call VecDestroy(vec_LP_cell_id, ierr);CHKERRQ(ierr)
  call VecDestroy(vec_LP_cell_id_loc, ierr);CHKERRQ(ierr)
  call VecScatterDestroy(VC_global2ghosted , ierr);CHKERRQ(ierr)
  call ISDestroy(is_ghosted, ierr);CHKERRQ(ierr)
  call ISDestroy(is_global, ierr);CHKERRQ(ierr)

end subroutine RealizationCreatenG2LP

! ************************************************************************** !

subroutine RealizationAddStrata(realization,strata)
  ! 
  ! Adds a copy of a strata to a list
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Strata_module

  implicit none
  
  type(realization_type) :: realization
  type(strata_type), pointer :: strata
  
  type(strata_type), pointer :: new_strata
  
  new_strata => StrataCreate(strata)
  call StrataAddToList(new_strata,realization%patch%strata)
  nullify(new_strata)
  
  call StrataDestroy(strata)
 
end subroutine RealizationAddStrata

! ************************************************************************** !

subroutine RealizationAddObservation(realization,observation)
  ! 
  ! Adds a copy of a observation object to a list
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Observation_module

  implicit none
  
  type(realization_type) :: realization
  type(observation_type), pointer :: observation
  
  type(observation_type), pointer :: new_observation
  
  new_observation => ObservationCreate(observation)
  call ObservationAddToList(new_observation, &
                            realization%patch%observation)
  nullify(new_observation)

  call ObservationDestroy(observation)
 
end subroutine RealizationAddObservation

! ************************************************************************** !

subroutine RealizationProcessCouplers(realization)
  ! 
  ! Sets connectivity and pointers for couplers
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  
  call PatchProcessCouplers( realization%patch,realization%flow_conditions, &
                             realization%transport_conditions, &
                             realization%option)
  
end subroutine RealizationProcessCouplers

! ************************************************************************** !

subroutine RealizationProcessConditions(realization)
  ! 
  ! Sets up auxiliary data associated with
  ! conditions
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/14/08
  ! 

  use Dataset_module
  
  implicit none
  
  type(realization_type) :: realization

  call DatasetScreenForNonCellIndexed(realization%datasets,realization%option)
  
  if (realization%option%nflowdof > 0) then
    call RealProcessFlowConditions(realization)
  endif
  if (realization%option%ntrandof > 0) then
    call RealProcessTranConditions(realization)
  endif
  if (associated(realization%flow_mass_transfer_list)) then
    call MassTransferInit(realization%flow_mass_transfer_list, &
                          realization%discretization, &
                          realization%datasets, &
                          realization%option)
    call MassTransferUpdate(realization%flow_mass_transfer_list, &
                            realization%patch%grid, &
                            realization%option)
  endif
  if (associated(realization%rt_mass_transfer_list)) then
    call MassTransferInit(realization%rt_mass_transfer_list, &
                          realization%discretization, &
                          realization%datasets, &
                          realization%option)
    call MassTransferUpdate(realization%rt_mass_transfer_list, &
                            realization%patch%grid, &
                            realization%option)
  endif


end subroutine RealizationProcessConditions

! ************************************************************************** !

subroutine RealProcessMatPropAndSatFunc(realization)
  ! 
  ! Sets up linkeage between material properties
  ! and saturation function, auxiliary arrays
  ! and datasets
  ! 
  ! Author: Glenn Hammond
  ! Date: 01/21/09, 01/12/11
  ! 

  use String_module
  use Dataset_Common_HDF5_class
  
  implicit none
  
  type(realization_type) :: realization
  
  PetscBool :: found
  PetscInt :: i
  type(option_type), pointer :: option
  type(material_property_type), pointer :: cur_material_property
  type(patch_type), pointer :: patch
  character(len=MAXSTRINGLENGTH) :: string
  class(dataset_base_type), pointer :: dataset
  type(root_property_type), pointer :: cur_root_property

  option => realization%option
  patch => realization%patch
  
  ! set up mirrored pointer arrays within patches to saturation functions
  ! and material properties
  patch%material_properties => realization%material_properties
  call MaterialPropConvertListToArray(patch%material_properties, &
                                      patch%material_property_array, &
                                      option)
  if (associated(realization%saturation_functions)) then
    patch%saturation_functions => realization%saturation_functions
    call SaturatFuncConvertListToArray(patch%saturation_functions, &
                                       patch%saturation_function_array, &
                                       option)
  endif
  if (associated(realization%characteristic_curves)) then
    patch%characteristic_curves => realization%characteristic_curves
    call CharCurvesConvertListToArray(patch%characteristic_curves, &
                                      patch%characteristic_curves_array, &
                                      option)
  endif
                                      
  ! create mapping of internal to external material id
  call MaterialCreateIntToExtMapping(patch%material_property_array, &
                                     patch%imat_internal_to_external)
    
  cur_material_property => realization%material_properties                            
  do                                      
    if (.not.associated(cur_material_property)) exit

    ! obtain saturation function id
    if (option%iflowmode /= NULL_MODE) then
      if (associated(patch%saturation_function_array)) then
        cur_material_property%saturation_function_id = &
          SaturationFunctionGetID(patch%saturation_functions, &
                             cur_material_property%saturation_function_name, &
                             cur_material_property%name,option)
      endif
      if (associated(patch%characteristic_curves_array)) then
        cur_material_property%saturation_function_id = &
          CharacteristicCurvesGetID(patch%characteristic_curves_array, &
                             cur_material_property%saturation_function_name, &
                             cur_material_property%name,option)
      endif
    endif
    
    ! if named, link dataset to property
    if (.not.StringNull(cur_material_property%porosity_dataset_name)) then
      string = 'MATERIAL_PROPERTY(' // trim(cur_material_property%name) // &
               '),POROSITY'
      dataset => &
        DatasetBaseGetPointer(realization%datasets, &
                              cur_material_property%porosity_dataset_name, &
                              string,option)
      select type(dataset)
        class is (dataset_common_hdf5_type)
          cur_material_property%porosity_dataset => dataset
        class default
          option%io_buffer = 'Incorrect dataset type for porosity.'
          call printErrMsg(option)
      end select
    endif
    if (.not.StringNull(cur_material_property%permeability_dataset_name)) then
      string = 'MATERIAL_PROPERTY(' // trim(cur_material_property%name) // &
               '),PERMEABILITY'
      dataset => &
        DatasetBaseGetPointer(realization%datasets, &
                              cur_material_property%permeability_dataset_name, &
                              string,option)
      select type(dataset)
        class is (dataset_common_hdf5_type)
          cur_material_property%permeability_dataset => dataset
        class default
          option%io_buffer = 'Incorrect dataset type for porosity.'
          call printErrMsg(option)
      end select      
    endif
    
    cur_material_property => cur_material_property%next
  enddo
  
  if (option%root_system) then
    call RootPropertyConvertListToArray(realization%root_properties, &
                                        realization%root_property_array, &
                                        option)
    patch%root_properties => realization%root_properties
    call RootPropertyConvertListToArray(patch%root_properties, &
                                        patch%root_property_array, &
                                        option)
    cur_root_property => realization%root_properties
    do
      if (.not.associated(cur_root_property)) exit
      if (.not.StringNull(cur_root_property%ssd_dataset_name)) then
        string = 'ROOT_PROPERTY(' // trim(cur_root_property%name) // &
                 '),SSD'
        dataset => &
          DatasetBaseGetPointer(realization%datasets, &
                                cur_root_property%ssd_dataset_name, &
                                string,option)
        select type(dataset)
          class is (dataset_common_hdf5_type)
            cur_root_property%ssd_dataset => dataset
          class default
            option%io_buffer = 'Incorrect dataset type for root ssd.'
            call printErrMsg(option)
        end select
      endif

      cur_root_property => cur_root_property%next
    enddo
  endif

end subroutine RealProcessMatPropAndSatFunc

! ************************************************************************** !

subroutine RealProcessFluidProperties(realization)
  ! 
  ! Sets up linkeage with fluid properties
  ! 
  ! Author: Glenn Hammond
  ! Date: 01/21/09
  ! 
  
  implicit none
  
  type(realization_type) :: realization
  
  PetscBool :: found
  type(option_type), pointer :: option
  type(fluid_property_type), pointer :: cur_fluid_property
  
  option => realization%option
  
  found = PETSC_FALSE
  cur_fluid_property => realization%fluid_properties                            
  do                                      
    if (.not.associated(cur_fluid_property)) exit
    found = PETSC_TRUE
    select case(trim(cur_fluid_property%phase_name))
      case('LIQUID')
        cur_fluid_property%phase_id = LIQUID_PHASE
      case('GAS')
        cur_fluid_property%phase_id = GAS_PHASE
      case default
        cur_fluid_property%phase_id = LIQUID_PHASE
    end select
    cur_fluid_property => cur_fluid_property%next
  enddo
  
  if (option%ntrandof > 0 .and. .not.found) then
    option%io_buffer = 'A fluid property must be present in input file' // &
                       ' for solute transport'
  endif
  
end subroutine RealProcessFluidProperties

! ************************************************************************** !

subroutine RealProcessFlowConditions(realization)
  ! 
  ! Sets linkage of flow conditions to dataset
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/26/11
  ! 

  use Dataset_Base_class
  use Dataset_module

  implicit none

  type(realization_type) :: realization
  
  type(flow_condition_type), pointer :: cur_flow_condition
  type(flow_sub_condition_type), pointer :: cur_flow_sub_condition
  type(option_type), pointer :: option
  character(len=MAXSTRINGLENGTH) :: string
  PetscInt :: i
  
  option => realization%option
  
  ! loop over flow conditions looking for linkage to datasets
  cur_flow_condition => realization%flow_conditions%first
  do
    if (.not.associated(cur_flow_condition)) exit
    string = 'flow_condition ' // trim(cur_flow_condition%name)
    ! find datum dataset
    call DatasetFindInList(realization%datasets,cur_flow_condition%datum, &
                           cur_flow_condition%default_time_storage, &
                           string,option)
    select case(option%iflowmode)
      case default
        do i = 1, size(cur_flow_condition%sub_condition_ptr)
          ! find dataset
          call DatasetFindInList(realization%datasets, &
                 cur_flow_condition%sub_condition_ptr(i)%ptr%dataset, &
                 cur_flow_condition%default_time_storage, &
                 string,option)
          ! find gradient dataset
          call DatasetFindInList(realization%datasets, &
                 cur_flow_condition%sub_condition_ptr(i)%ptr%gradient, &
                 cur_flow_condition%default_time_storage, &
                 string,option)
        enddo
    end select
    cur_flow_condition => cur_flow_condition%next
  enddo

end subroutine RealProcessFlowConditions

! ************************************************************************** !

subroutine RealProcessTranConditions(realization)
  ! 
  ! Sets up auxiliary data associated with
  ! transport conditions
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/14/08
  ! 

  use String_module
  use Reaction_module
  use Constraint_module
  
  implicit none
  
  type(realization_type) :: realization
  
  
  PetscBool :: found
  type(option_type), pointer :: option
  type(tran_condition_type), pointer :: cur_condition
  type(tran_constraint_coupler_type), pointer :: cur_constraint_coupler
  type(tran_constraint_type), pointer :: cur_constraint, another_constraint
  
  option => realization%option
  
  ! check for duplicate constraint names
  cur_constraint => realization%transport_constraints%first
  do
    if (.not.associated(cur_constraint)) exit
      another_constraint => cur_constraint%next
      ! now compare names
      found = PETSC_FALSE
      do
        if (.not.associated(another_constraint)) exit
        if (StringCompare(cur_constraint%name,another_constraint%name, &
            MAXWORDLENGTH)) then
          found = PETSC_TRUE
        endif
        another_constraint => another_constraint%next
      enddo
      if (found) then
        option%io_buffer = 'Duplicate transport constraints named "' // &
                 trim(cur_constraint%name) // '"'
        call printErrMsg(realization%option)
      endif
    cur_constraint => cur_constraint%next
  enddo
  
  ! initialize constraints
  cur_constraint => realization%transport_constraints%first
  do
    if (.not.associated(cur_constraint)) exit
    call ReactionProcessConstraint(realization%reaction, &
                                   cur_constraint%name, &
                                   cur_constraint%aqueous_species, &
                                   cur_constraint%minerals, &
                                   cur_constraint%surface_complexes, &
                                   cur_constraint%colloids, &
                                   cur_constraint%immobile_species, &
                                   realization%option)
    cur_constraint => cur_constraint%next
  enddo
  
  if (option%use_mc) then
    call ReactionProcessConstraint(realization%reaction, &
                                   realization%sec_transport_constraint%name, &
                                   realization%sec_transport_constraint%aqueous_species, &
                                   realization%sec_transport_constraint%minerals, &
                                   realization%sec_transport_constraint%surface_complexes, &
                                   realization%sec_transport_constraint%colloids, &
                                   realization%sec_transport_constraint%immobile_species, &
                                   realization%option)
  endif
  
  ! tie constraints to couplers, if not already associated
  cur_condition => realization%transport_conditions%first
  do

    if (.not.associated(cur_condition)) exit
    cur_constraint_coupler => cur_condition%constraint_coupler_list
    do
      if (.not.associated(cur_constraint_coupler)) exit
      if (.not.associated(cur_constraint_coupler%aqueous_species)) then
        cur_constraint => realization%transport_constraints%first
        do
          if (.not.associated(cur_constraint)) exit
          if (StringCompare(cur_constraint%name, &
                             cur_constraint_coupler%constraint_name, &
                             MAXWORDLENGTH)) then
            cur_constraint_coupler%aqueous_species => cur_constraint%aqueous_species
            cur_constraint_coupler%minerals => cur_constraint%minerals
            cur_constraint_coupler%surface_complexes => cur_constraint%surface_complexes
            cur_constraint_coupler%colloids => cur_constraint%colloids
            cur_constraint_coupler%immobile_species => cur_constraint%immobile_species
            exit
          endif
          cur_constraint => cur_constraint%next
        enddo
        if (.not.associated(cur_constraint_coupler%aqueous_species)) then
          option%io_buffer = 'Transport constraint "' // &
                   trim(cur_constraint_coupler%constraint_name) // &
                   '" not found in input file constraints.'
          call printErrMsg(realization%option)
        endif
      endif
      cur_constraint_coupler => cur_constraint_coupler%next
    enddo
    if (associated(cur_condition%constraint_coupler_list%next)) then ! more than one
      cur_condition%is_transient = PETSC_TRUE
    else
      cur_condition%is_transient = PETSC_FALSE
    endif
    cur_condition => cur_condition%next
  enddo
 
  ! final details for setup
  cur_condition => realization%transport_conditions%first
  do
    if (.not.associated(cur_condition)) exit
    ! is the condition transient?
    if (associated(cur_condition%constraint_coupler_list%next)) then ! more than one
      cur_condition%is_transient = PETSC_TRUE
    else
      cur_condition%is_transient = PETSC_FALSE
    endif
    ! set pointer to first constraint coupler
    cur_condition%cur_constraint_coupler => cur_condition%constraint_coupler_list
    
    cur_condition => cur_condition%next
  enddo

end subroutine RealProcessTranConditions

! ************************************************************************** !

subroutine RealizationInitConstraints(realization)
  ! 
  ! Initializes constraint concentrations
  ! 
  ! Author: Glenn Hammond
  ! Date: 12/04/08
  ! 

  implicit none

  type(realization_type) :: realization
  
  type(patch_type), pointer :: cur_patch
  
  cur_patch => realization%patch_list%first
  do
    if (.not.associated(cur_patch)) exit
    call PatchInitConstraints(cur_patch,realization%reaction, &
                              realization%option)
    cur_patch => cur_patch%next
  enddo
 
end subroutine RealizationInitConstraints

! ************************************************************************** !

subroutine RealizationPrintCouplers(realization)
  ! 
  ! Print boundary and initial condition data
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/28/08
  ! 

  use Coupler_module
  
  implicit none
  
  type(realization_type) :: realization
  
  type(patch_type), pointer :: cur_patch
  type(coupler_type), pointer :: cur_coupler
  type(option_type), pointer :: option
  type(reaction_type), pointer :: reaction
 
  option => realization%option
  reaction => realization%reaction
 
  if (.not.OptionPrintToFile(option)) return
  
  cur_patch => realization%patch_list%first
  do
    if (.not.associated(cur_patch)) exit

    cur_coupler => cur_patch%initial_conditions%first
    do
      if (.not.associated(cur_coupler)) exit
      call RealizationPrintCoupler(cur_coupler,reaction,option)    
      cur_coupler => cur_coupler%next
    enddo
     
    cur_coupler => cur_patch%boundary_conditions%first
    do
      if (.not.associated(cur_coupler)) exit
      call RealizationPrintCoupler(cur_coupler,reaction,option)    
      cur_coupler => cur_coupler%next
    enddo
     
    cur_coupler => cur_patch%source_sinks%first
    do
      if (.not.associated(cur_coupler)) exit
      call RealizationPrintCoupler(cur_coupler,reaction,option)    
      cur_coupler => cur_coupler%next
    enddo

    cur_patch => cur_patch%next
  enddo
    
end subroutine RealizationPrintCouplers

! ************************************************************************** !

subroutine RealizationPrintCoupler(coupler,reaction,option)
  ! 
  ! Prints boundary and initial condition coupler
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/28/08
  ! 

  use Coupler_module
  use Reaction_module
  
  implicit none
  
  type(coupler_type) :: coupler
  type(option_type) :: option
  type(reaction_type), pointer :: reaction
  
  character(len=MAXSTRINGLENGTH) :: string
  
  type(flow_condition_type), pointer :: flow_condition
  type(tran_condition_type), pointer :: tran_condition
  type(region_type), pointer :: region
  type(tran_constraint_coupler_type), pointer :: constraint_coupler
   
98 format(40('=+'))
99 format(80('-'))
100 format(a)
  
  flow_condition => coupler%flow_condition
  tran_condition => coupler%tran_condition
  region => coupler%region

  write(option%fid_out,*)
  write(option%fid_out,98)


  select case(coupler%itype)
    case(INITIAL_COUPLER_TYPE)
      string = 'Initial Condition'
    case(BOUNDARY_COUPLER_TYPE)
      string = 'Boundary Condition'
    case(SRC_SINK_COUPLER_TYPE)
      string = 'Source Sink'
  end select
  write(option%fid_out,'(/,2x,a,/)') trim(string)

  write(option%fid_out,99)
101 format(5x,'     Flow Condition: ',2x,a)
  if (associated(flow_condition)) &
    write(option%fid_out,101) trim(flow_condition%name)
102 format(5x,'Transport Condition: ',2x,a)
  if (associated(tran_condition)) &
    write(option%fid_out,102) trim(tran_condition%name)
103 format(5x,'             Region: ',2x,a)
  if (associated(region)) &
    write(option%fid_out,103) trim(region%name)
  write(option%fid_out,99)
  
  if (associated(flow_condition)) then
    call FlowConditionPrint(flow_condition,option)
  endif
  if (associated(tran_condition)) then
    constraint_coupler => tran_condition%cur_constraint_coupler
    write(option%fid_out,'(/,2x,''Transport Condition: '',a)') &
      trim(tran_condition%name)
    if (associated(reaction)) then
      call ReactionPrintConstraint(constraint_coupler,reaction,option)
      write(option%fid_out,'(/)')
      write(option%fid_out,99)
    endif
  endif
 
end subroutine RealizationPrintCoupler

! ************************************************************************** !

subroutine RealizationInitAllCouplerAuxVars(realization)
  ! 
  ! RealizationInitCouplerAuxVars: Initializes coupler auxillary variables
  ! within list
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  
  !geh: Must update conditions prior to initializing the aux vars.  
  !     Otherwise, datasets will not have been read for routines such as
  !     hydrostatic and auxvars will be initialized to garbage.
  call FlowConditionUpdate(realization%flow_conditions,realization%option, &
                           realization%option%time)
  call TranConditionUpdate(realization%transport_conditions, &
                           realization%option, &
                           realization%option%time)  
  call PatchInitAllCouplerAuxVars(realization%patch,realization%option)
   
end subroutine RealizationInitAllCouplerAuxVars

! ************************************************************************** !

subroutine RealizUpdateAllCouplerAuxVars(realization,force_update_flag)
  ! 
  ! Updates auxiliary variables associated
  ! with couplers in lis
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  PetscBool :: force_update_flag

  !TODO(geh): separate flow from transport in these calls
  call PatchUpdateAllCouplerAuxVars(realization%patch,force_update_flag, &
                                    realization%option)

end subroutine RealizUpdateAllCouplerAuxVars

! ************************************************************************** !

subroutine RealizationUpdate(realization)
  ! 
  ! Update parameters in realization (e.g. conditions, bcs, srcs)
  ! 
  ! Author: Glenn Hammond
  ! Date: 11/09/07
  ! 

  implicit none
  
  type(realization_type) :: realization
  
  PetscBool :: force_update_flag = PETSC_FALSE
  
  ! must update conditions first
  call FlowConditionUpdate(realization%flow_conditions,realization%option, &
                           realization%option%time)
  call TranConditionUpdate(realization%transport_conditions, &
                           realization%option, &
                           realization%option%time)
  call RealizUpdateAllCouplerAuxVars(realization,force_update_flag)
  if (associated(realization%uniform_velocity_dataset)) then
    call RealizUpdateUniformVelocity(realization)
  endif
! currently don't use auxvars, just condition for src/sinks
!  call RealizationUpdateSrcSinks(realization)

  call MassTransferUpdate(realization%flow_mass_transfer_list, &
                          realization%patch%grid, &
                          realization%option)

  call MassTransferUpdate(realization%rt_mass_transfer_list, &
                          realization%patch%grid, &
                          realization%option)

end subroutine RealizationUpdate

! ************************************************************************** !

subroutine RealizationRevertFlowParameters(realization)
  ! 
  ! Assigns initial porosity/perms to vecs
  ! 
  ! Author: Glenn Hammond
  ! Date: 05/09/08
  ! 

  use Option_module
  use Field_module
  use Discretization_module
  use Material_Aux_class
  use Variables_module

  implicit none
  
  type(realization_type) :: realization
  
  type(field_type), pointer :: field
  type(option_type), pointer :: option
  type(discretization_type), pointer :: discretization
  type(material_type), pointer :: Material
  
  option => realization%option
  field => realization%field
  discretization => realization%discretization
  Material => realization%patch%aux%Material

  if (option%nflowdof > 0) then
    call DiscretizationGlobalToLocal(discretization,field%perm0_xx, &
                                     field%work_loc,ONEDOF)  
    call MaterialSetAuxVarVecLoc(Material,field%work_loc,PERMEABILITY_X,0)
    call DiscretizationGlobalToLocal(discretization,field%perm0_yy, &
                                     field%work_loc,ONEDOF)  
    call MaterialSetAuxVarVecLoc(Material,field%work_loc,PERMEABILITY_Y,0)
    call DiscretizationGlobalToLocal(discretization,field%perm0_zz, &
                                     field%work_loc,ONEDOF)  
    call MaterialSetAuxVarVecLoc(Material,field%work_loc,PERMEABILITY_Z,0)
  endif   
  call DiscretizationGlobalToLocal(discretization,field%porosity0, &
                                    field%work_loc,ONEDOF)  
  call MaterialSetAuxVarVecLoc(Material,field%work_loc,POROSITY,0)
  call DiscretizationGlobalToLocal(discretization,field%tortuosity0, &
                                    field%work_loc,ONEDOF)  
  call MaterialSetAuxVarVecLoc(Material,field%work_loc,TORTUOSITY,0)

end subroutine RealizationRevertFlowParameters

! ************************************************************************** !

subroutine RealizUpdateUniformVelocity(realization)
  ! 
  ! Assigns uniform velocity for transport
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/22/08
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  
  call UniformVelocityDatasetUpdate(realization%option, &
                                    realization%option%time, &
                                    realization%uniform_velocity_dataset)
  call PatchUpdateUniformVelocity(realization%patch, &
                            realization%uniform_velocity_dataset%cur_value, &
                            realization%option)
 
end subroutine RealizUpdateUniformVelocity

! ************************************************************************** !

subroutine RealizationAddWaypointsToList(realization)
  ! 
  ! Creates waypoints associated with source/sinks
  ! boundary conditions, etc. and add to list
  ! 
  ! Author: Glenn Hammond
  ! Date: 11/01/07
  ! 

  use Option_module
  use Waypoint_module
  use Time_Storage_module
  use Strata_module

  implicit none
  
  type(realization_type) :: realization
  
  type(waypoint_list_type), pointer :: waypoint_list
  type(flow_condition_type), pointer :: cur_flow_condition
  type(tran_condition_type), pointer :: cur_tran_condition
  type(flow_sub_condition_type), pointer :: sub_condition
  type(tran_constraint_coupler_type), pointer :: cur_constraint_coupler
  type(mass_transfer_type), pointer :: cur_mass_transfer
  type(waypoint_type), pointer :: waypoint, cur_waypoint
  type(option_type), pointer :: option
  type(strata_type), pointer :: cur_strata
  PetscInt :: itime, isub_condition
  PetscReal :: temp_real, final_time
  PetscReal, pointer :: times(:)

  option => realization%option
  waypoint_list => realization%waypoint_list
  nullify(times)
  
  ! set flag for final output
  cur_waypoint => waypoint_list%first
  do
    if (.not.associated(cur_waypoint)) exit
    if (cur_waypoint%final) then
      cur_waypoint%print_output = realization%output_option%print_final
      exit
    endif
    cur_waypoint => cur_waypoint%next
  enddo
  ! use final time in conditional below
  if (associated(cur_waypoint)) then
    final_time = cur_waypoint%time
  else
    option%io_buffer = 'Final time not found in RealizationAddWaypointsToList'
    call printErrMsg(option)
  endif

  ! add update of flow conditions
  cur_flow_condition => realization%flow_conditions%first
  do
    if (.not.associated(cur_flow_condition)) exit
    if (cur_flow_condition%sync_time_with_update) then
      do isub_condition = 1, cur_flow_condition%num_sub_conditions
        sub_condition => cur_flow_condition%sub_condition_ptr(isub_condition)%ptr
        !TODO(geh): check if this updated more than simply the flow_dataset (i.e. datum and gradient)
        !geh: followup - no, datum/gradient are not considered.  Should they be considered?
        call TimeStorageGetTimes(sub_condition%dataset%time_storage, option, &
                                final_time, times)
        if (associated(times)) then
          if (size(times) > 4000) then
            option%io_buffer = 'For flow condition "' // &
              trim(cur_flow_condition%name) // &
              '" dataset "' // trim(sub_condition%name) // &
              '", the number of times is excessive for synchronization ' // &
              'with waypoints.'
            call printErrMsg(option)
          endif
          do itime = 1, size(times)
            waypoint => WaypointCreate()
            waypoint%time = times(itime)
            waypoint%update_conditions = PETSC_TRUE
            call WaypointInsertInList(waypoint,waypoint_list)
          enddo
          deallocate(times)
          nullify(times)
        endif
      enddo
    endif
    cur_flow_condition => cur_flow_condition%next
  enddo
      
  ! add update of transport conditions
  cur_tran_condition => realization%transport_conditions%first
  do
    if (.not.associated(cur_tran_condition)) exit
    if (cur_tran_condition%is_transient) then
      cur_constraint_coupler => cur_tran_condition%constraint_coupler_list
      do
        if (.not.associated(cur_constraint_coupler)) exit
        if (cur_constraint_coupler%time > 1.d-40) then
          waypoint => WaypointCreate()
          waypoint%time = cur_constraint_coupler%time
          waypoint%update_conditions = PETSC_TRUE
          call WaypointInsertInList(waypoint,waypoint_list)
        endif
        cur_constraint_coupler => cur_constraint_coupler%next
      enddo
    endif
    cur_tran_condition => cur_tran_condition%next
  enddo

  ! add update of velocity fields
  if (associated(realization%uniform_velocity_dataset)) then
    if (realization%uniform_velocity_dataset%times(1) > 1.d-40 .or. &
        size(realization%uniform_velocity_dataset%times) > 1) then
      do itime = 1, size(realization%uniform_velocity_dataset%times)
        waypoint => WaypointCreate()
        waypoint%time = realization%uniform_velocity_dataset%times(itime)
        waypoint%update_conditions = PETSC_TRUE
        call WaypointInsertInList(waypoint,waypoint_list)
      enddo
    endif
  endif
  
  ! add waypoints for flow mass transfer
  if (associated(realization%flow_mass_transfer_list)) then
    cur_mass_transfer => realization%flow_mass_transfer_list
    do
      if (.not.associated(cur_mass_transfer)) exit
      if (associated(cur_mass_transfer%dataset%time_storage)) then
        do itime = 1, cur_mass_transfer%dataset%time_storage%max_time_index
          waypoint => WaypointCreate()
          waypoint%time = cur_mass_transfer%dataset%time_storage%times(itime)
          waypoint%update_conditions = PETSC_TRUE
          call WaypointInsertInList(waypoint,realization%waypoint_list)
        enddo
      endif
      cur_mass_transfer => cur_mass_transfer%next
    enddo
  endif  

  ! add waypoints for rt mass transfer
  if (associated(realization%rt_mass_transfer_list)) then
    cur_mass_transfer => realization%rt_mass_transfer_list
    do
      if (.not.associated(cur_mass_transfer)) exit
      if (associated(cur_mass_transfer%dataset%time_storage)) then
        do itime = 1, cur_mass_transfer%dataset%time_storage%max_time_index
          waypoint => WaypointCreate()
          waypoint%time = cur_mass_transfer%dataset%time_storage%times(itime)
          waypoint%update_conditions = PETSC_TRUE
          call WaypointInsertInList(waypoint,realization%waypoint_list)
        enddo
      endif
      cur_mass_transfer => cur_mass_transfer%next
    enddo
  endif  

  ! add waypoints for periodic output
  if (realization%output_option%periodic_output_time_incr > 0.d0 .or. &
      realization%output_option%periodic_tr_output_time_incr > 0.d0) then

    if (realization%output_option%periodic_output_time_incr > 0.d0) then
      ! standard output
      temp_real = 0.d0
      do
        temp_real = temp_real + realization%output_option%periodic_output_time_incr
        if (temp_real > final_time) exit
        waypoint => WaypointCreate()
        waypoint%time = temp_real
        waypoint%print_output = PETSC_TRUE
        call WaypointInsertInList(waypoint,realization%waypoint_list)
      enddo
    endif
    
    if (realization%output_option%periodic_tr_output_time_incr > 0.d0) then
      ! transient observation output
      temp_real = 0.d0
      do
        temp_real = temp_real + realization%output_option%periodic_tr_output_time_incr
        if (temp_real > final_time) exit
        waypoint => WaypointCreate()
        waypoint%time = temp_real
        waypoint%print_tr_output = PETSC_TRUE 
        call WaypointInsertInList(waypoint,realization%waypoint_list)
      enddo
    endif

  endif

  ! add waypoints for periodic checkpoint
  if (realization%output_option%periodic_checkpoint_time_incr > 0.d0) then

    ! standard output
    temp_real = 0.d0
    do
      temp_real = temp_real + realization%output_option%periodic_checkpoint_time_incr
      if (temp_real > final_time) exit
      waypoint => WaypointCreate()
      waypoint%time = temp_real
      waypoint%print_checkpoint = PETSC_TRUE
      call WaypointInsertInList(waypoint,realization%waypoint_list)
    enddo
  endif

  ! add in strata that change over time
  cur_strata => realization%patch%strata%first
  do
    if (.not.associated(cur_strata)) exit
    if (Initialized(cur_strata%start_time)) then
      waypoint => WaypointCreate()
      waypoint%time = cur_strata%start_time
      waypoint%sync = PETSC_TRUE
      call WaypointInsertInList(waypoint,realization%waypoint_list)
    endif
    if (Initialized(cur_strata%end_time)) then
      waypoint => WaypointCreate()
      waypoint%time = cur_strata%end_time
      waypoint%sync = PETSC_TRUE
      call WaypointInsertInList(waypoint,realization%waypoint_list)
    endif
    cur_strata => cur_strata%next
  enddo

end subroutine RealizationAddWaypointsToList

! ************************************************************************** !

function RealizCreateSyncWaypointList(realization)
  ! 
  ! Creates a list of waypoints for outer synchronization of simulation process
  ! model couplers
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/08/14
  ! 

  use Option_module
  use Waypoint_module
  use Time_Storage_module

  implicit none
  
  type(realization_type) :: realization
  
  type(waypoint_list_type), pointer :: RealizCreateSyncWaypointList

  type(waypoint_list_type), pointer :: new_waypoint_list
  type(waypoint_type), pointer :: cur_waypoint
  type(waypoint_type), pointer :: new_waypoint

  new_waypoint_list => WaypointListCreate()
  
  cur_waypoint => realization%waypoint_list%first
  do
    if (.not.associated(cur_waypoint)) exit
    if (cur_waypoint%sync .or. cur_waypoint%final) then
      new_waypoint => WaypointCreate(cur_waypoint)
      call WaypointInsertInList(new_waypoint,new_waypoint_list)
      if (cur_waypoint%final) exit
    endif
    cur_waypoint => cur_waypoint%next
  enddo
  RealizCreateSyncWaypointList => new_waypoint_list

end function RealizCreateSyncWaypointList

! ************************************************************************** !

subroutine RealizationUpdatePropertiesTS(realization)
  ! 
  ! Updates coupled properties at each grid cell
  ! 
  ! Author: Glenn Hammond
  ! Date: 08/05/09
  ! 

  use Grid_module
  use Reactive_Transport_Aux_module
  use Material_Aux_class
  use Variables_module, only : POROSITY, TORTUOSITY, PERMEABILITY_X, &
                               PERMEABILITY_Y, PERMEABILITY_Z
 
  implicit none
  
  type(realization_type) :: realization

  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(field_type), pointer :: field
  type(reaction_type), pointer :: reaction
  type(grid_type), pointer :: grid
  type(material_property_ptr_type), pointer :: material_property_array(:)
  type(reactive_transport_auxvar_type), pointer :: rt_auxvars(:) 
  type(discretization_type), pointer :: discretization
  class(material_auxvar_type), pointer :: material_auxvars(:)

  PetscInt :: local_id, ghosted_id
  PetscInt :: imnrl, imnrl1, imnrl_armor, imat
  PetscReal :: sum_volfrac
  PetscReal :: scale, porosity_scale, volfrac_scale
  PetscBool :: porosity_updated
  PetscReal, pointer :: vec_p(:)
  PetscReal, pointer :: porosity0_p(:)
  PetscReal, pointer :: porosity_mnrl_loc_p(:)
  PetscReal, pointer :: tortuosity0_p(:)
  PetscReal, pointer :: perm0_xx_p(:), perm0_yy_p(:), perm0_zz_p(:)
  PetscReal :: min_value  
  PetscInt :: ivalue
  PetscErrorCode :: ierr

  option => realization%option
  discretization => realization%discretization
  patch => realization%patch
  field => realization%field
  reaction => realization%reaction
  grid => patch%grid
  material_property_array => patch%material_property_array
  rt_auxvars => patch%aux%RT%auxvars
  material_auxvars => patch%aux%Material%auxvars

  if (.not.associated(patch%imat)) then
    option%io_buffer = 'Materials IDs not present in run.  Material ' // &
      ' properties cannot be updated without material ids ask Glenn'
    call printErrMsg(option)
  endif

  porosity_updated = PETSC_FALSE
  if (reaction%update_porosity) then
    porosity_updated = PETSC_TRUE
  
    if (reaction%mineral%nkinmnrl > 0) then
      call VecGetArrayF90(field%porosity0,porosity0_p,ierr);CHKERRQ(ierr)
      call VecGetArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                          ierr);CHKERRQ(ierr)
      do local_id = 1, grid%nlmax
        ghosted_id = grid%nL2G(local_id)
        ! Go ahead and compute for inactive cells since their porosity does
        ! not matter (avoid check on active/inactive)
        sum_volfrac = 0.d0
        do imnrl = 1, reaction%mineral%nkinmnrl
          sum_volfrac = sum_volfrac + &
                        rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl)
        enddo 
        ! the adjusted porosity becomes:
        ! 1 - sum(porosity0 + mineral volume fractions), but is truncated.
        porosity_mnrl_loc_p(ghosted_id) = &
          max(porosity0_p(local_id)-sum_volfrac,reaction%minimum_porosity)
      enddo
      call VecRestoreArrayF90(field%porosity0,porosity0_p,ierr);CHKERRQ(ierr)
      call VecRestoreArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                              ierr);CHKERRQ(ierr)
    endif
    
    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 POROSITY,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 POROSITY,ZERO_INTEGER)
  endif
  
  if ((porosity_updated .and. &
       (reaction%update_tortuosity .or. &
        reaction%update_permeability)) .or. &
      ! if porosity ratio is used in mineral surface area update, we must
      ! recalculate it every time.
      (reaction%update_mineral_surface_area .and. &
       reaction%update_mnrl_surf_with_porosity)) then
    call VecGetArrayF90(field%porosity0,porosity0_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                        ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
    do local_id = 1, grid%nlmax
      ghosted_id = grid%nL2G(local_id)
      vec_p(local_id) = porosity_mnrl_loc_p(ghosted_id) / porosity0_p(local_id)
    enddo
    call VecRestoreArrayF90(field%porosity0,porosity0_p,ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                            ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
  endif      

  if (reaction%update_mineral_surface_area) then

    if (reaction%update_mnrl_surf_with_porosity) then
      ! placing the get/restore array calls within the condition will
      ! avoid improper access.
      call VecGetArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
    endif

    do local_id = 1, grid%nlmax
      ghosted_id = grid%nL2G(local_id)
      do imnrl = 1, reaction%mineral%nkinmnrl

        porosity_scale = 1.d0
        if (reaction%update_mnrl_surf_with_porosity) then
          porosity_scale = vec_p(local_id)** &
             reaction%mineral%kinmnrl_surf_area_porosity_pwr(imnrl)
!       geh: srf_area_vol_frac_pwr must be defined on a per mineral basis, not
!       solely material type.
!       material_property_array(patch%imat(ghosted_id))%ptr%mnrl_surf_area_porosity_pwr
        endif

        volfrac_scale = 1.d0
        if (rt_auxvars(ghosted_id)%mnrl_volfrac0(imnrl) > 0.d0) then
          volfrac_scale = (rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl)/ &
                         rt_auxvars(ghosted_id)%mnrl_volfrac0(imnrl))** &
             reaction%mineral%kinmnrl_surf_area_vol_frac_pwr(imnrl)
!       geh: srf_area_vol_frac_pwr must be defined on a per mineral basis, not
!       solely material type.
!       material_property_array(patch%imat(ghosted_id))%ptr%mnrl_surf_area_volfrac_pwr
!         rt_auxvars(ghosted_id)%mnrl_area(imnrl) = &
!           rt_auxvars(ghosted_id)%mnrl_area0(imnrl)*porosity_scale*volfrac_scale
!       else
!         rt_auxvars(ghosted_id)%mnrl_area(imnrl) = &
!           rt_auxvars(ghosted_id)%mnrl_area0(imnrl)
        endif

        rt_auxvars(ghosted_id)%mnrl_area(imnrl) = &
            rt_auxvars(ghosted_id)%mnrl_area0(imnrl)*porosity_scale*volfrac_scale

        if (reaction%update_armor_mineral_surface .and. &
            reaction%mineral%kinmnrl_armor_crit_vol_frac(imnrl) > 0.d0) then
          imnrl_armor = imnrl
          do imnrl1 = 1, reaction%mineral%nkinmnrl
            if (reaction%mineral%kinmnrl_armor_min_names(imnrl) == &
                reaction%mineral%kinmnrl_names(imnrl1)) then
              imnrl_armor = imnrl1
              exit
            endif
          enddo

!         print *,'update-armor: ',imnrl,imnrl_armor, &
!         reaction%mineral%kinmnrl_armor_min_names(imnrl_armor)

!       check for negative surface area armoring correction
          if (reaction%mineral%kinmnrl_armor_crit_vol_frac(imnrl) > &
              rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl_armor)) then

            if (reaction%update_armor_mineral_surface_flag == 0) then ! surface unarmored
              rt_auxvars(ghosted_id)%mnrl_area(imnrl) = &
                rt_auxvars(ghosted_id)%mnrl_area(imnrl) * &
                ((reaction%mineral%kinmnrl_armor_crit_vol_frac(imnrl) &
                - rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl_armor))/ &
                reaction%mineral%kinmnrl_armor_crit_vol_frac(imnrl))** &
                reaction%mineral%kinmnrl_surf_area_vol_frac_pwr(imnrl)
            else
              rt_auxvars(ghosted_id)%mnrl_area(imnrl) = rt_auxvars(ghosted_id)%mnrl_area0(imnrl)
              reaction%update_armor_mineral_surface_flag = 0
            endif
          else
            rt_auxvars(ghosted_id)%mnrl_area(imnrl) = 0.d0
            reaction%update_armor_mineral_surface_flag = 1 ! surface armored
          endif
        endif

!       print *,'update min srf: ',imnrl,local_id,reaction%mineral%kinmnrl_names(imnrl), &
!       reaction%mineral%kinmnrl_armor_min_names(imnrl), &
!       reaction%update_armor_mineral_surface, &
!       rt_auxvars(ghosted_id)%mnrl_area(imnrl), &
!       reaction%mineral%kinmnrl_armor_pwr(imnrl), &
!       reaction%mineral%kinmnrl_armor_crit_vol_frac(imnrl), &
!       rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl_armor), &
!       rt_auxvars(ghosted_id)%mnrl_volfrac(imnrl)
      enddo
    enddo

    if (reaction%update_mnrl_surf_with_porosity) then
      call VecRestoreArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
    endif
!geh:remove
    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 TORTUOSITY,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 TORTUOSITY,ZERO_INTEGER)
  endif
      
  if (reaction%update_tortuosity) then
    call VecGetArrayF90(field%tortuosity0,tortuosity0_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
    do local_id = 1, grid%nlmax
      ghosted_id = grid%nL2G(local_id)
      scale = vec_p(local_id)** &
        material_property_array(patch%imat(ghosted_id))%ptr%tortuosity_pwr
      material_auxvars(ghosted_id)%tortuosity = &
        tortuosity0_p(local_id)*scale
    enddo
    call VecRestoreArrayF90(field%tortuosity0,tortuosity0_p, &
                            ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%work,vec_p,ierr);CHKERRQ(ierr)
    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 TORTUOSITY,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 TORTUOSITY,ZERO_INTEGER)
  endif
      
  if (reaction%update_permeability) then
    call VecGetArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                        ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%perm0_xx,perm0_xx_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%perm0_zz,perm0_zz_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%perm0_yy,perm0_yy_p,ierr);CHKERRQ(ierr)
!   call VecGetArrayF90(field%work,vec_p,ierr)
    do local_id = 1, grid%nlmax
      ghosted_id = grid%nL2G(local_id)
      imat = patch%imat(ghosted_id)
      if (porosity_mnrl_loc_p(ghosted_id) >= &
          material_property_array(imat)%ptr%permeability_crit_por) then
        scale = ((porosity_mnrl_loc_p(ghosted_id) - &
                  material_property_array(imat)%ptr%permeability_crit_por) &
                /(porosity0_p(local_id) - &
                  material_property_array(imat)%ptr%permeability_crit_por))** &
                material_property_array(imat)%ptr%permeability_pwr

#ifdef PERM
        scale = scale*((1.001-porosity0_p(local_id)**2.d0) / &
                (1.001-porosity_mnrl_loc_p(ghosted_id)**2.d0))
#endif
      option%io_buffer = 'Incorrect scaling in RealizationUpdatePropertiesPatch()'
      call printErrMsg(option)
      !geh: I am not sure who wrote this but it cannot possibly be correct!!!
        if (scale < material_property_array(patch%imat(ghosted_id))%ptr%permeability_min_scale_fac) &
          scale = material_property_array(patch%imat(ghosted_id))%ptr%permeability_min_scale_fac
      else
        scale = material_property_array(patch%imat(ghosted_id))%ptr%permeability_min_scale_fac
      endif
!     scale = vec_p(local_id)** &
!             material_property_array(patch%imat(ghosted_id))%ptr%permeability_pwr
      material_auxvars(ghosted_id)%permeability(perm_xx_index) = &
        perm0_xx_p(local_id)*scale
      material_auxvars(ghosted_id)%permeability(perm_yy_index) = &
        perm0_yy_p(local_id)*scale
      material_auxvars(ghosted_id)%permeability(perm_zz_index) = &
        perm0_zz_p(local_id)*scale
    enddo
    call VecRestoreArrayF90(field%porosity_mnrl_loc,porosity_mnrl_loc_p, &
                            ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%perm0_xx,perm0_xx_p,ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%perm0_zz,perm0_zz_p,ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%perm0_yy,perm0_yy_p,ierr);CHKERRQ(ierr)

    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_X,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_X,ZERO_INTEGER)
    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_Y,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_Y,ZERO_INTEGER)
    call MaterialGetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_Z,ZERO_INTEGER)
    call DiscretizationLocalToLocal(discretization,field%work_loc, &
                                    field%work_loc,ONEDOF)
    call MaterialSetAuxVarVecLoc(patch%aux%Material,field%work_loc, &
                                 PERMEABILITY_Z,ZERO_INTEGER)
  endif  
  
  ! perform check to ensure that porosity is bounded between 0 and 1
  ! since it is calculated as 1.d-sum_volfrac, it cannot be > 1
  call VecMin(field%porosity_mnrl_loc,ivalue,min_value,ierr);CHKERRQ(ierr)
  if (min_value < 0.d0) then
    write(option%io_buffer,*) 'Sum of mineral volume fractions has ' // &
      'exceeded 1.d0 at cell (note PETSc numbering): ', ivalue
    call printErrMsg(option)
  endif
   
end subroutine RealizationUpdatePropertiesTS

! ************************************************************************** !

subroutine RealizationUpdatePropertiesNI(realization)
  ! 
  ! Updates coupled properties at each grid cell
  ! 
  ! Author: Glenn Hammond
  ! Date: 08/05/09
  ! 

  use Grid_module
  use Reactive_Transport_Aux_module
  use Material_Aux_class
  use Variables_module, only : POROSITY, TORTUOSITY, PERMEABILITY_X, &
                               PERMEABILITY_Y, PERMEABILITY_Z
 
  implicit none
  
  type(realization_type) :: realization

#if 0
  type(option_type), pointer :: option
  type(patch_type), pointer :: patch
  type(field_type), pointer :: field
  type(reaction_type), pointer :: reaction
  type(grid_type), pointer :: grid
  type(material_property_ptr_type), pointer :: material_property_array(:)
  type(reactive_transport_auxvar_type), pointer :: rt_auxvars(:) 
  type(discretization_type), pointer :: discretization
  class(material_auxvar_type), pointer :: material_auxvars(:)

  PetscInt :: local_id, ghosted_id
  PetscInt :: imnrl, imnrl1, imnrl_armor, imat
  PetscReal :: sum_volfrac
  PetscReal :: scale, porosity_scale, volfrac_scale
  PetscBool :: porosity_updated
  PetscReal, pointer :: vec_p(:)
  PetscReal, pointer :: porosity0_p(:)
  PetscReal, pointer :: porosity_mnrl_loc_p(:)
  PetscReal, pointer :: tortuosity0_p(:)
  PetscReal, pointer :: perm0_xx_p(:), perm0_yy_p(:), perm0_zz_p(:)
  PetscReal :: min_value  
  PetscInt :: ivalue
  PetscErrorCode :: ierr

  option => realization%option
  discretization => realization%discretization
  patch => realization%patch
  field => realization%field
  reaction => realization%reaction
  grid => patch%grid
  material_property_array => patch%material_property_array
  rt_auxvars => patch%aux%RT%auxvars
  material_auxvars => patch%aux%Material%auxvars
#endif

end subroutine RealizationUpdatePropertiesNI

! ************************************************************************** !

subroutine RealLocalToLocalWithArray(realization,array_id)
  ! 
  ! Takes an F90 array that is ghosted
  ! and updates the ghosted values
  ! 
  ! Author: Glenn Hammond
  ! Date: 06/09/11
  ! 

  use Grid_module

  implicit none

  type(realization_type) :: realization
  PetscInt :: array_id
  
  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(field_type), pointer :: field

  field => realization%field
  patch => realization%patch

  grid => patch%grid
  select case(array_id)
    case(MATERIAL_ID_ARRAY)
      call GridCopyIntegerArrayToVec(grid,patch%imat,field%work_loc, &
                                     grid%ngmax)
    case(SATURATION_FUNCTION_ID_ARRAY)
      call GridCopyIntegerArrayToVec(grid,patch%sat_func_id, &
                                     field%work_loc, grid%ngmax)
  end select

  call DiscretizationLocalToLocal(realization%discretization,field%work_loc, &
                                  field%work_loc,ONEDOF)

  select case(array_id)
    case(MATERIAL_ID_ARRAY)
      call GridCopyVecToIntegerArray(grid,patch%imat,field%work_loc, &
                                      grid%ngmax)
    case(SATURATION_FUNCTION_ID_ARRAY)
      call GridCopyVecToIntegerArray(grid,patch%sat_func_id, &
                                      field%work_loc, grid%ngmax)
  end select

end subroutine RealLocalToLocalWithArray

! ************************************************************************** !

subroutine RealizationCountCells(realization,global_total_count, &
                                 global_active_count,total_count,active_count)
  ! 
  ! Counts # of active and inactive grid cells
  ! 
  ! Author: Glenn Hammond
  ! Date: 06/01/10
  ! 

  use Option_module

  implicit none
  
  type(realization_type) :: realization
  PetscInt :: global_total_count
  PetscInt :: global_active_count
  PetscInt :: total_count
  PetscInt :: active_count
  
  PetscInt :: patch_total_count
  PetscInt :: patch_active_count
  PetscInt :: temp_int_in(2), temp_int_out(2)
  PetscErrorCode :: ierr
  
  type(patch_type), pointer :: patch
  
  total_count = 0
  active_count = 0
    
  patch => realization%patch
  call PatchCountCells(patch,patch_total_count,patch_active_count)
  total_count = total_count + patch_total_count
  active_count = active_count + patch_active_count
  
  temp_int_in(1) = total_count
  temp_int_in(2) = active_count
  call MPI_Allreduce(temp_int_in,temp_int_out,TWO_INTEGER_MPI,MPIU_INTEGER, &
                     MPI_SUM,realization%option%mycomm,ierr)
  global_total_count = temp_int_out(1)
  global_active_count = temp_int_out(2)

end subroutine RealizationCountCells

! ************************************************************************** !

subroutine RealizationSetUpBC4Faces(realization)

  use Connection_module
  use Coupler_module
  use Patch_module
  use Grid_module
  use Field_module
  use MFD_Aux_module
  

#include "finclude/petscvec.h"
#include "finclude/petscvec.h90"

  type(realization_type) :: realization

#ifdef DASVYAT
  type(grid_type), pointer :: grid
  type(patch_type), pointer :: patch
  type(field_type), pointer :: field
  

  type(mfd_auxvar_type), pointer :: auxvar
  type(connection_set_type), pointer :: conn
  type(coupler_type), pointer ::  boundary_condition

  PetscReal, pointer :: bc_faces_p(:), xx_faces_p(:)
  PetscInt :: iconn, sum_connection, bc_type, bound_id
  PetscInt :: local_id, ghosted_id, ghost_face_id, j, jface, local_face_id
  PetscErrorCode :: ierr

  patch => realization%patch
  grid => patch%grid
  field => realization%field

  call VecGetArrayF90(field%flow_bc_loc_faces, bc_faces_p, ierr);CHKERRQ(ierr)
  call VecGetArrayF90(field%flow_xx_faces, xx_faces_p, ierr);CHKERRQ(ierr)

  boundary_condition => patch%boundary_conditions%first
  sum_connection = 0
  do
    if (.not.associated(boundary_condition)) exit
    bc_type = boundary_condition%flow_condition%itype(RICHARDS_PRESSURE_DOF)

    do iconn = 1, boundary_condition%numfaces_set
      sum_connection = sum_connection + 1

      local_id = boundary_condition%region%cell_ids(iconn)
      ghosted_id = grid%nL2G(local_id)

      auxvar => grid%MFD%auxvars(local_id)
      do j = 1, auxvar%numfaces
        ghost_face_id = auxvar%face_id_gh(j)
        local_face_id = grid%fG2L(ghost_face_id)
        conn => grid%faces(ghost_face_id)%conn_set_ptr
        jface = grid%faces(ghost_face_id)%id
        if (boundary_condition%faces_set(iconn) == ghost_face_id) then
          if ((bc_type == DIRICHLET_BC).or.(bc_type == HYDROSTATIC_BC)  &
              .or.(bc_type == SEEPAGE_BC).or.(bc_type == CONDUCTANCE_BC) ) then
            bc_faces_p(ghost_face_id) = boundary_condition%flow_aux_real_var(1,iconn)*conn%area(jface)
            xx_faces_p(local_face_id) = boundary_condition%flow_aux_real_var(1,iconn)
          else if ((bc_type == NEUMANN_BC)) then
            bc_faces_p(ghost_face_id) = boundary_condition%flow_aux_real_var(1,iconn)*conn%area(jface)
            bound_id = grid%fL2B(local_face_id)
            if (bound_id>0) then
              patch%boundary_velocities(realization%option%nphase, bound_id) = &
                boundary_condition%flow_aux_real_var(1,iconn)
            endif
          endif
        endif
      enddo
    enddo
    boundary_condition => boundary_condition%next
  enddo

  call VecRestoreArrayF90(field%flow_xx_faces, xx_faces_p, ierr);CHKERRQ(ierr)
  call VecRestoreArrayF90(field%flow_bc_loc_faces, bc_faces_p,  &
                          ierr);CHKERRQ(ierr)

#endif

end subroutine RealizationSetUpBC4Faces

! ************************************************************************** !

subroutine RealizationPrintGridStatistics(realization)
  ! 
  ! Prints statistics regarding the numerical
  ! discretization
  ! 
  ! Author: Glenn Hammond
  ! Date: 06/01/10
  ! 

  use Grid_module

  implicit none

  type(realization_type) :: realization
  
  type(option_type), pointer :: option
  type(grid_type), pointer :: grid

  PetscInt :: i1, i2, i3
  PetscReal :: r1, r2, r3
  PetscInt :: global_total_count, global_active_count
  PetscInt :: total_count, active_count
  PetscReal :: total_min, total_max, total_mean, total_variance
  PetscReal :: active_min, active_max, active_mean, active_variance
  PetscInt :: inactive_histogram(12), temp_int_out(12)
  PetscReal :: inactive_percentages(12)
  PetscErrorCode :: ierr

  option => realization%option
  grid => realization%patch%grid

  ! print # of active and inactive grid cells
  call RealizationCountCells(realization,global_total_count, &
                             global_active_count,total_count,active_count)
  r1 = dble(total_count)
  call OptionMaxMinMeanVariance(r1,total_max, &
                                total_min,total_mean, &
                                total_variance,PETSC_TRUE,option)
  r1 = dble(active_count)
  call OptionMaxMinMeanVariance(r1,active_max, &
                                active_min,active_mean, &
                                active_variance,PETSC_TRUE,option)
                  
  r1 = dble(active_count) / dble(total_count)    
  inactive_histogram = 0                          
  if (r1 >= (1.d0-1.d-8)) then
    inactive_histogram(12) = 1
  else if (r1 >= .9d0 .and. r1 < (1.d0-1.d-8)) then
    inactive_histogram(11) = 1
  else if (r1 >= .8d0 .and. r1 < .9d0) then
    inactive_histogram(10) = 1
  else if (r1 >= .7d0 .and. r1 < .8d0) then
    inactive_histogram(9) = 1
  else if (r1 >= .6d0 .and. r1 < .7d0) then
    inactive_histogram(8) = 1
  else if (r1 >= .5d0 .and. r1 < .6d0) then
    inactive_histogram(7) = 1
  else if (r1 >= .4d0 .and. r1 < .5d0) then
    inactive_histogram(6) = 1
  else if (r1 >= .3d0 .and. r1 < .4d0) then
    inactive_histogram(5) = 1
  else if (r1 >= .2d0 .and. r1 < .3d0) then
    inactive_histogram(4) = 1
  else if (r1 >= .1d0 .and. r1 < .2d0) then
    inactive_histogram(3) = 1
  else if (r1 > 1.d-20 .and. r1 < .1d0) then
    inactive_histogram(2) = 1
  else if (r1 < 1.d-20) then
    inactive_histogram(1) = 1
  endif
  
  call MPI_Allreduce(inactive_histogram,temp_int_out,TWELVE_INTEGER_MPI, &
                     MPIU_INTEGER,MPI_SUM,option%mycomm,ierr)

  ! why I cannot use *100, I do not know....geh
  inactive_percentages = dble(temp_int_out)/dble(option%mycommsize)*10.d0
  inactive_percentages = inactive_percentages+1.d-8

  r1 = 0.d0
  do i1 = 1, 12
    r1 = r1 + inactive_percentages(i1)
  enddo
                                
  i1 = UNINITIALIZED_INTEGER
  i2 = UNINITIALIZED_INTEGER
  i3 = UNINITIALIZED_INTEGER
  if (associated(grid%structured_grid)) then
    i1 = grid%structured_grid%npx_final
    i2 = grid%structured_grid%npy_final
    i3 = grid%structured_grid%npz_final
  endif
  if (OptionPrintToScreen(option)) then
    write(*,'(/," Grid Stats:",/, &
              & "                       Global # cells: ",i12,/, &
              & "                Global # active cells: ",i12,/, &
              & "                              # cores: ",i12,/, &
              & "         Processor core decomposition: ",3i6,/, &
              & "               Maximum # cells / core: ",i12,/, &
              & "               Minimum # cells / core: ",i12,/, &
              & "               Average # cells / core: ",1pe12.4,/, &
              & "               Std Dev # cells / core: ",1pe12.4,/, &
              & "        Maximum # active cells / core: ",i12,/, &
              & "        Minimum # active cells / core: ",i12,/, &
              & "        Average # active cells / core: ",1pe12.4,/, &
              & "        Std Dev # active cells / core: ",1pe12.4,/,/, &
              & "        % cores with % active cells =       0%: ",1f7.2,/, &
              & "        % cores with % active cells =  0.1-10%: ",1f7.2,/, &
              & "        % cores with % active cells =   10-20%: ",1f7.2,/, &
              & "        % cores with % active cells =   20-30%: ",1f7.2,/, &
              & "        % cores with % active cells =   30-40%: ",1f7.2,/, &
              & "        % cores with % active cells =   40-50%: ",1f7.2,/, &
              & "        % cores with % active cells =   50-60%: ",1f7.2,/, &
              & "        % cores with % active cells =   60-70%: ",1f7.2,/, &
              & "        % cores with % active cells =   70-80%: ",1f7.2,/, &
              & "        % cores with % active cells =   80-90%: ",1f7.2,/, &
              & "        % cores with % active cells = 90-99.9%: ",1f7.2,/, &
              & "        % cores with % active cells =     100%: ",1f7.2,/, &
              & "                                        Check : ",1f7.2,/)') &
           global_total_count, &
           global_active_count, &
           option%mycommsize, &
           i1,i2,i3, &
           int(total_max+1.d-4), &
           int(total_min+1.d-4), &
           total_mean, sqrt(total_variance), &
           int(active_max+1.d-4), &
           int(active_min+1.d-4), &
           active_mean, sqrt(active_variance), &
           inactive_percentages(1), &
           inactive_percentages(2), &
           inactive_percentages(3), &
           inactive_percentages(4), &
           inactive_percentages(5), &
           inactive_percentages(6), &
           inactive_percentages(7), &
           inactive_percentages(8), &
           inactive_percentages(9), &
           inactive_percentages(10), &
           inactive_percentages(11), &
           inactive_percentages(12), &
           r1
  endif
  if (OptionPrintToFile(option)) then
    write(option%fid_out,'(/," Grid Stats:",/, &
               & "                       Global # cells: ",i12,/, &
               & "                Global # active cells: ",i12,/, &
               & "                              # cores: ",i12,/, &
               & "         Processor core decomposition: ",3i6,/, &
               & "               Maximum # cells / core: ",i12,/, &
               & "               Minimum # cells / core: ",i12,/, &
               & "               Average # cells / core: ",1pe12.4,/, &
               & "               Std Dev # cells / core: ",1pe12.4,/, &
               & "        Maximum # active cells / core: ",i12,/, &
               & "        Minimum # active cells / core: ",i12,/, &
               & "        Average # active cells / core: ",1pe12.4,/, &
               & "        Std Dev # active cells / core: ",1pe12.4,/,/, &
               & "        % cores with % active cells =       0%: ",1f7.2,/, &
               & "        % cores with % active cells =  0.1-10%: ",1f7.2,/, &
               & "        % cores with % active cells =   10-20%: ",1f7.2,/, &
               & "        % cores with % active cells =   20-30%: ",1f7.2,/, &
               & "        % cores with % active cells =   30-40%: ",1f7.2,/, &
               & "        % cores with % active cells =   40-50%: ",1f7.2,/, &
               & "        % cores with % active cells =   50-60%: ",1f7.2,/, &
               & "        % cores with % active cells =   60-70%: ",1f7.2,/, &
               & "        % cores with % active cells =   70-80%: ",1f7.2,/, &
               & "        % cores with % active cells =   80-90%: ",1f7.2,/, &
               & "        % cores with % active cells = 90-99.9%: ",1f7.2,/, &
               & "        % cores with % active cells =     100%: ",1f7.2,/, &
               & "                                        Check : ",1f7.2,/)') &
           global_total_count, &
           global_active_count, &
           option%mycommsize, &
           i1,i2,i3, &
           int(total_max+1.d-4), &
           int(total_min+1.d-4), &
           total_mean, sqrt(total_variance), &
           int(active_max+1.d-4), &
           int(active_min+1.d-4), &
           active_mean, sqrt(active_variance), &
           inactive_percentages(1), &
           inactive_percentages(2), &
           inactive_percentages(3), &
           inactive_percentages(4), &
           inactive_percentages(5), &
           inactive_percentages(6), &
           inactive_percentages(7), &
           inactive_percentages(8), &
           inactive_percentages(9), &
           inactive_percentages(10), &
           inactive_percentages(11), &
           inactive_percentages(12), &
           r1
  endif

end subroutine RealizationPrintGridStatistics

! ************************************************************************** !

subroutine RealizationCalculateCFL1Timestep(realization,max_dt_cfl_1)
  ! 
  ! Calculates largest time step that
  ! preserves a CFL # of 1 in a realization
  ! 
  ! Author: Glenn Hammond
  ! Date: 10/07/11
  ! 

  implicit none

  type(realization_type) realization
  PetscReal :: max_dt_cfl_1
  
  type(patch_type), pointer :: patch
  PetscReal :: max_dt_cfl_1_patch
  PetscReal :: tempreal
  PetscErrorCode :: ierr
  
  max_dt_cfl_1 = 1.d20
  patch => realization%patch
  call PatchCalculateCFL1Timestep(patch,realization%option, &
                                  max_dt_cfl_1_patch)
  max_dt_cfl_1 = min(max_dt_cfl_1,max_dt_cfl_1_patch)

  ! get the minimum across all cores
  call MPI_Allreduce(max_dt_cfl_1,tempreal,ONE_INTEGER_MPI, &
                     MPI_DOUBLE_PRECISION,MPI_MIN, &
                     realization%option%mycomm,ierr)
  max_dt_cfl_1 = tempreal

end subroutine RealizationCalculateCFL1Timestep

! ************************************************************************** !

subroutine RealizationNonInitializedData(realization)
  ! 
  ! Checks for non-initialized data sets
  ! i.e. porosity, permeability
  ! 
  ! Author: Glenn Hammond
  ! Date: 02/08/13
  ! 

  use Grid_module
  use Patch_module
  use Option_module
  use Field_module

  implicit none
  
  type(realization_type) :: realization
  
  type(patch_type), pointer :: patch
  type(grid_type), pointer :: grid
  type(option_type), pointer :: option
  type(field_type), pointer :: field  
  PetscReal, pointer :: vec_p(:), vecy_p(:), vecz_p(:)
  PetscReal :: min_value, global_value
  PetscInt :: local_id
  PetscErrorCode :: ierr
  
  patch => realization%patch
  grid => patch%grid
  option => realization%option
  field => realization%field
  
  ! cannot use VecMin as there may be inactive cells without data assigned.
  
  min_value = 1.d20
  ! porosity
  call VecGetArrayF90(field%porosity0,vec_p,ierr);CHKERRQ(ierr)
  do local_id = 1, grid%nlmax
    if (patch%imat(grid%nL2G(local_id)) <= 0) cycle
    min_value = min(min_value,vec_p(local_id)) 
  enddo
  call VecRestoreArrayF90(field%porosity0,vec_p,ierr);CHKERRQ(ierr)
  call MPI_Allreduce(min_value,global_value,ONE_INTEGER_MPI, &
                     MPI_DOUBLE_PRECISION,MPI_MIN,option%mycomm,ierr)
  
  if (Uninitialized(global_value)) then
    option%io_buffer = 'Porosity not initialized at all cells.  ' // &
                       'Ensure that REGIONS cover entire domain!!!'
    call printErrMsg(option)
  endif
  
  if (option%iflowmode /= NULL_MODE) then
    call VecGetArrayF90(field%perm0_xx,vec_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%perm0_yy,vecy_p,ierr);CHKERRQ(ierr)
    call VecGetArrayF90(field%perm0_zz,vecz_p,ierr);CHKERRQ(ierr)
    min_value = 1.d20
    do local_id = 1, grid%nlmax
      if (patch%imat(grid%nL2G(local_id)) <= 0) cycle
      min_value = min(min_value,vec_p(local_id),vecy_p(local_id), &
                      vecz_p(local_id)) 
    enddo        
    call VecRestoreArrayF90(field%perm0_xx,vec_p,ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%perm0_yy,vecy_p,ierr);CHKERRQ(ierr)
    call VecRestoreArrayF90(field%perm0_zz,vecz_p,ierr);CHKERRQ(ierr)
    call MPI_Allreduce(min_value,global_value,ONE_INTEGER_MPI, &
                       MPI_DOUBLE_PRECISION,MPI_MIN,option%mycomm,ierr)
    if (global_value < 1.d-60) then
      option%io_buffer = &
        'A positive non-zero permeability must be defined throughout ' // &
        'domain in X, Y and Z.'
      call printErrMsg(option)
    endif
  endif

end subroutine RealizationNonInitializedData

! ************************************************************************** !

subroutine RealizationDestroyLegacy(realization)
  ! 
  ! Deallocates a realization
  ! 
  ! Author: Glenn Hammond
  ! Date: 11/01/07
  ! 

  use Dataset_module

  implicit none
  
  type(realization_type), pointer :: realization
  
  if (.not.associated(realization)) return
    
  call FieldDestroy(realization%field)

!  call OptionDestroy(realization%option) !geh it will be destroy externally
  call OutputOptionDestroy(realization%output_option)
  call RegionDestroyList(realization%regions)
  
  call FlowConditionDestroyList(realization%flow_conditions)
  call TranConditionDestroyList(realization%transport_conditions)
  call TranConstraintDestroyList(realization%transport_constraints)

  call PatchDestroyList(realization%patch_list)

  if (associated(realization%debug)) deallocate(realization%debug)
  nullify(realization%debug)
  
  if (associated(realization%fluid_property_array)) &
    deallocate(realization%fluid_property_array)
  nullify(realization%fluid_property_array)
  call FluidPropertyDestroy(realization%fluid_properties)
  
  call MaterialPropertyDestroy(realization%material_properties)

  call SaturationFunctionDestroy(realization%saturation_functions)
  print *, 'RealizationDestroyLegacy cannot be removed.'
  stop
  call CharacteristicCurvesDestroy(realization%characteristic_curves)

  call DatasetDestroy(realization%datasets)
  
  call UniformVelocityDatasetDestroy(realization%uniform_velocity_dataset)
  
  call DiscretizationDestroy(realization%discretization)
  
  call ReactionDestroy(realization%reaction,realization%option)
  
  call TranConstraintDestroy(realization%sec_transport_constraint)
  call MassTransferDestroy(realization%flow_mass_transfer_list)
  call MassTransferDestroy(realization%rt_mass_transfer_list)
  
  call WaypointListDestroy(realization%waypoint_list)
  
  if (associated(realization%root_property_array)) &
    deallocate(realization%root_property_array)
  call RootPropertyDestroy(realization%root_properties)

  deallocate(realization)
  nullify(realization)
  
end subroutine RealizationDestroyLegacy

! ************************************************************************** !

subroutine RealizationStrip(this)
  ! 
  ! Deallocates a realization
  ! 
  ! Author: Glenn Hammond
  ! Date: 11/01/07
  ! 

  use Dataset_module

  implicit none
  
  class(realization_type) :: this
  
  call RealizationBaseStrip(this)
  call RegionDestroyList(this%regions)
  
  call FlowConditionDestroyList(this%flow_conditions)
  call TranConditionDestroyList(this%transport_conditions)
  call TranConstraintDestroyList(this%transport_constraints)

  if (associated(this%fluid_property_array)) &
    deallocate(this%fluid_property_array)
  nullify(this%fluid_property_array)
  call FluidPropertyDestroy(this%fluid_properties)
  
  call MaterialPropertyDestroy(this%material_properties)

  call SaturationFunctionDestroy(this%saturation_functions)
  call CharacteristicCurvesDestroy(this%characteristic_curves)  

  call DatasetDestroy(this%datasets)
  
  call UniformVelocityDatasetDestroy(this%uniform_velocity_dataset)
  
  call ReactionDestroy(this%reaction,this%option)
  
  call TranConstraintDestroy(this%sec_transport_constraint)
  
  call WaypointListDestroy(this%waypoint_list)
  
end subroutine RealizationStrip

end module Realization_class
